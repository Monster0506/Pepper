diff --git i/main.py w/main.py
index 314c8cf..6a26cdb 100644
--- i/main.py
+++ w/main.py
@@ -1,5 +1,6 @@
 import argparse
 import re
+import ast
 from dataclasses import dataclass
 from typing import List, Dict, Any, Optional
 import random
@@ -18,6 +19,7 @@ LOOP_END_KEYWORD = "LOOP_END"
 INPUT_KEYWORD = "INPT"
 GOTO_KEYWORD = "GOTO"
 LABEL_KEYWORD = "LBL"
+RETURN_KEYWORD = "RETURN"  # Added for clarity
 
 
 @dataclass
@@ -29,1041 +31,1615 @@ class Function:
 
 
 class ExpressionEvaluator:
-    def __init__(self, variables, debug=False):
+    def __init__(self, variables, functions, interpreter, debug=False):
+        # Added functions
         self.variables = variables
+        self.interpreter = interpreter
+
+        # Keep a reference to functions for function calls within expressions
+        self.functions = functions
         self.debug = debug
-        self.operators = {
-            "+": lambda x, y: x + y,
-            "-": lambda x, y: x - y,
-            "*": lambda x, y: x * y,
-            "/": lambda x, y: x / y if y != 0 else float("inf"),
-            "%": lambda x, y: x % y if y != 0 else float("inf"),
-            "**": lambda x, y: x**y,
-            "!/": lambda x, y: x // y if y != 0 else float("inf"),
-        }
+        # Removed self.operators as it wasn't used consistently
         self.type_conversions = {
             ("int", "float"): float,
             ("float", "int"): int,
             ("int", "bool"): bool,
-            ("string", "list"): lambda x: [str(c) for c in x],
+            ("float", "bool"): bool,
+            ("string", "list"): lambda x: list(x),  # Simpler list conversion
             ("any", "string"): str,
             ("int", "string"): str,
             ("float", "string"): str,
             ("bool", "string"): str,
-            ("list", "string"): lambda x: str(x),
-            ("string", "int"): lambda x: int(float(x))
-            if x.replace(".", "").isdigit()
-            else 0,
-            ("string", "float"): lambda x: float(x)
-            if x.replace(".", "").isdigit()
-            else 0.0,
+            # More sensible list to string
+            ("list", "string"): lambda x: "".join(map(str, x)),
+            ("string", "int"): lambda x: int(x) if x.strip().lstrip('-').isdigit() else (_raise(ValueError(f"Cannot convert '{x}' to int"))),
+            ("string", "float"): lambda x: float(x) if _is_float(x) else (_raise(ValueError(f"Cannot convert '{x}' to float"))),
+            ("string", "bool"): lambda x: x.lower() == 'true',
             ("void", "any"): lambda _: None,
-            ("any", "void"): lambda x: x,
+            # Return None when converting to void
+            ("any", "void"): lambda _: None,
+            ("list", "bool"): lambda x: bool(x),  # List to bool
+            ("bool", "int"): lambda x: 1 if x else 0,  # Bool to int
+            ("bool", "float"): lambda x: 1.0 if x else 0.0,  # Bool to float
         }
 
-    def evaluate(self, expression, expected_type):
+    def evaluate(self, expression: str, expected_type: Optional[str]):
         """Main evaluation method that routes to appropriate sub-evaluators"""
+        expression = expression.strip()
+        if not expression:
+            raise ValueError("Cannot evaluate empty expression")
+
         if self.debug:
             print(
                 f"Evaluating expression: '{expression}' with expected type: {expected_type}"
             )
-        if expression[0] == '"' and expression[-1] == '"':
-            return expression[1:-1]
-        if expression in self.variables:
+
+        # 1. Direct Variable Lookup
+        if re.fullmatch(r"[a-zA-Z_]\w*", expression) and expression in self.variables:
             value, var_type = self.variables[expression]
-            if expected_type is None or var_type == expected_type:
-                return value
+            if self.debug:
+                print(
+                    f"  Variable '{expression}' found: value={value}, type={var_type}")
             return self._convert_type(value, var_type, expected_type)
-        # Handle string concatenation first if the expression contains '+'
-        if "+" in expression and (expected_type == "string" or expected_type is None):
+
+        # 2. Literals
+        literal_result = self._evaluate_literal(expression, expected_type)
+        if literal_result is not None:
+            if self.debug:
+                print(
+                    f"  Evaluated as literal: {literal_result} (requested: {expected_type})")
+            return literal_result  # _evaluate_literal now handles conversion
+
+        # 3. Input Expression
+        input_match = re.fullmatch(r'INPT\("([^"]*)"\)', expression)
+        if input_match:
+            if self.debug:
+                print(f"  Evaluating as INPUT")
+            return self._evaluate_input(input_match, expected_type)
+
+        # 4. Type Conversion Expression
+        type_conv_match = re.fullmatch(r"(.+?)\s*:>\s*(\w+)", expression)
+        if type_conv_match:
+            if self.debug:
+                print(f"  Evaluating as type conversion")
+            # Pass expected_type
+            return self._evaluate_type_conversion(type_conv_match, expected_type)
+
+        # 5. List Literals
+        list_literal_match = re.fullmatch(
+            r"\[.*\]", expression, re.DOTALL)  # Handle multiline
+        if list_literal_match:
+            if self.debug:
+                print(f"  Evaluating as list literal")
+            # Evaluate list literal first, then convert if needed
+            raw_list = self._evaluate_list_literal(list_literal_match)
+            return self._convert_type(raw_list, "list", expected_type)
+
+        # 6. List Operations
+        list_op_match = re.fullmatch(
+            # Use \S+ for non-quoted values
+            r'([a-zA-Z_]\w*)\s+("[^"]*"|\S+)\s+\[(a|r|n|p|P)\](?:\s+("[^"]*"|\S+))?',
+            expression
+        )
+        if list_op_match:
+            if self.debug:
+                print(f"  Evaluating as list operation")
+            # List operations modify in-place and return the list
+            modified_list = self._evaluate_list_operation(list_op_match)
+            # Update the variable directly
+            list_name = list_op_match.group(1)
+            self.variables[list_name] = (
+                modified_list, self.variables[list_name][1])
+            return self._convert_type(modified_list, self.variables[list_name][1], expected_type)
+
+        list_len_match = re.fullmatch(r"([a-zA-Z_]\w*)\s+\[l\]", expression)
+        if list_len_match:
+            if self.debug:
+                print(f"  Evaluating as list length")
+            length = self._evaluate_list_length(list_len_match)
+            return self._convert_type(length, "int", expected_type)
+
+        list_rand_match = re.fullmatch(r"([a-zA-Z_]\w*)\s+\[\?\]", expression)
+        if list_rand_match:
+            if self.debug:
+                print(f"  Evaluating as list random choice")
+            choice = self._evaluate_list_random(list_rand_match)
+            # Determine type of choice dynamically
+            choice_type = _get_python_type_name(choice)
+            return self._convert_type(choice, choice_type, expected_type)
+
+        # Note: Using 1-based indexing for users
+        list_idx_match = re.fullmatch(
+            r"([a-zA-Z_]\w*)\s+\[i\]\s+(.+)", expression)
+        if list_idx_match:
+            if self.debug:
+                print(f"  Evaluating as list indexing (1-based)")
+            item = self._evaluate_list_indexing(list_idx_match)
+            if item is None:  # Handle index out of range returning None
+                return None
+            item_type = _get_python_type_name(item)
+            return self._convert_type(item, item_type, expected_type)
+
+        # Note: Using 1-based indexing for users
+        list_find_match = re.fullmatch(
+            r"([a-zA-Z_]\w*)\s+\[f\]\s+(.+)", expression)
+        if list_find_match:
+            if self.debug:
+                print(f"  Evaluating as list find (1-based index, 0 if not found)")
+            index = self._evaluate_list_finding(list_find_match)
+            return self._convert_type(index, "int", expected_type)
+
+        # 7. Function Call within expression (e.g. LET x:int = (5) |> addOne)
+        func_call_match = re.fullmatch(
+            r"(\(.*?\)|_)\s*\|>\s*([a-zA-Z_]\w*)", expression)
+        if func_call_match:
+            if self.debug:
+                print(f"  Evaluating as function call within expression")
+         # Call the interpreter's handler, passing the expression line,
+         # the current variables, and this evaluator instance for arg evaluation
             try:
+                # Pass the raw expression string as the 'line' argument
+                return_value = self.interpreter.handle_function_call(
+                    expression, self.variables, self)
+            # Get the type of the actual returned value
+                return_type = _get_python_type_name(return_value)
+            # Convert the return value to the type expected by the outer expression
+                return self._convert_type(return_value, return_type, expected_type)
+            except (ValueError, TypeError, IndexError) as e:
+                # Re-raise errors from function call handling appropriately
+                raise ValueError(
+                    f"Error during function call '{expression}': {e}") from e
+
+        # 8. String Concatenation (Only if '+' is present and not handled by RPN)
+        # Be careful not to catch simple additions like "x + 1" if expected is numeric
+        if "+" in expression and '"' in expression:  # Basic heuristic: quotes imply potential string concat
+            try:
+                if self.debug:
+                    print(f"  Attempting string concatenation")
                 result = self._evaluate_string_concatenation(expression)
-                if result is not None:
-                    return result
+                return self._convert_type(result, "string", expected_type)
             except ValueError:
-                pass
+                if self.debug:
+                    print(f"  String concatenation failed, continuing...")
+                pass  # Fall through if not a valid string concat
 
-        # Then try other evaluation methods
-        evaluators = [
-            (r'INPT\("([^"]*)"\)', self._evaluate_input),
-            (r"([a-zA-Z_]\w*)\s*:>\s*(\w+)", self._evaluate_type_conversion),
-            (r"\[.+\]", self._evaluate_list_literal),
-            (
-                r"(.+)\s*(@\$@|#\$#|[<>]=?|&&|&\$\$&)\s*(.+)",
-                self._evaluate_boolean_expression,
-            ),
-            (r"~@\s+(.+)", self._evaluate_boolean_expression),
-            (
-                r'([a-zA-Z_]\w*)\s+("[^"]*"|\d+)\s+\[(a|r|n|p|P)\](?:\s+("[^"]*"|\d+))?',
-                self._evaluate_list_operation,
-            ),
-            (r"([a-zA-Z_]\w*)\s+\[l\]", self._evaluate_list_length),
-            (r"([a-zA-Z_]\w*)\s+\[\?\]", self._evaluate_list_random),
-            (r"([a-zA-Z_]\w*)\s+\[i\]\s+(.+)", self._evaluate_list_indexing),
-            (r"([a-zA-Z_]\w*)\s+\[f\]\s+(.+)", self._evaluate_list_finding),
-        ]
+        # 9. Boolean Expressions (Infix)
+        bool_match_infix = re.fullmatch(
+            r"(.+?)\s*(@\$@|#\$#|&&|&\$\$&|[<>]=?)\s*(.+)", expression
+        )
+        if bool_match_infix:
+            if self.debug:
+                print(f"  Evaluating as infix boolean expression")
+            result = self._evaluate_boolean_expression_infix(bool_match_infix)
+            return self._convert_type(result, "bool", expected_type)
 
-        for pattern, evaluator in evaluators:
-            match = re.match(pattern, expression)
-            if match:
-                return evaluator(match, expected_type)
+        # 10. Boolean Negation (Prefix)
+        bool_match_neg = re.fullmatch(r"~@\s+(.+)", expression)
+        if bool_match_neg:
+            if self.debug:
+                print(f"  Evaluating as boolean negation")
+            result = self._evaluate_boolean_negation(bool_match_neg)
+            return self._convert_type(result, "bool", expected_type)
 
-        # Try RPN evaluation for numeric expressions
-        if expected_type in ("int", "float", None):
+        # 11. RPN Arithmetic/Numeric (Last resort for things that look numeric)
+        # Simple check: contains digits and operators, no quotes?
+        if re.search(r"[\d\.\s+\-*/%?]", expression) and not re.search(r'"', expression):
             try:
+                if self.debug:
+                    print(f"  Attempting RPN evaluation")
+                # Handle ? for random number generation within RPN
                 if "?" in expression:
-                    # Replace ? with random number and ensure proper RPN spacing
                     parts = expression.split()
                     for i, part in enumerate(parts):
                         if "?" in part:
+                            # Simple replacement, might need refinement for complex cases
                             parts[i] = str(random.random())
                     expression = " ".join(parts)
+
                 result = self._evaluate_rpn(expression)
-                if expected_type == "int":
-                    return int(result)
-                return result
-            except ValueError:
-                pass
-        # string literal
+                # Determine result type (int or float)
+                result_type = "int" if isinstance(result, int) else "float"
+                return self._convert_type(result, result_type, expected_type)
+            except (ValueError, ZeroDivisionError, TypeError) as e:
+                if self.debug:
+                    print(f"  RPN evaluation failed: {e}")
+                # Fall through if RPN fails
+            except IndexError:
+                if self.debug:
+                    print(f"  RPN evaluation failed: Not enough operands")
 
-        literal_result = self._evaluate_literal(expression, expected_type)
-        if literal_result is not None:
-            return literal_result
-
-        raise ValueError(f"Unable to evaluate expression: {expression}")
+        # If nothing else matches, raise Error
+        raise ValueError(f"Unable to evaluate expression: '{expression}'")
 
     def _evaluate_input(self, match, expected_type):
         """Evaluates input expressions."""
         prompt = match.group(1)
         user_input = input(prompt + " ")
 
-        try:
-            if expected_type == "int":
-                return int(user_input)
-            elif expected_type == "float":
-                return float(user_input)
-            elif expected_type == "bool":
-                return user_input.lower() == "true"
-            elif expected_type == "string":
-                return user_input
-            elif expected_type == "list":
-                # Parse input as comma-separated values
-                return [x.strip() for x in user_input.split(",")]
-            else:
-                return user_input
-        except ValueError:
-            raise ValueError(
-                f"Cannot convert input '{user_input}' to type {expected_type}"
-            )
+        # Try to convert directly to the expected type
+        if expected_type:
+            try:
+                # Use a temporary conversion map based on expected_type
+                temp_conversions = {
+                    "int": int,
+                    "float": float,
+                    "bool": lambda x: x.lower() == "true",
+                    "string": str,
+                    "list": lambda x: [e.strip() for e in x.split(',')],
+                }
+                if expected_type in temp_conversions:
+                    return temp_conversions[expected_type](user_input)
+                else:  # Fallback for unknown types or None
+                    return user_input
+            except ValueError:
+                raise ValueError(
+                    f"Input '{user_input}' cannot be converted to expected type {expected_type}"
+                )
+        else:
+            # If no expected type, return as string
+            return user_input
 
     def _evaluate_literal(self, expression, expected_type):
-        """Evaluates literal values with automatic type conversion"""
-        # String literals
-        if expression.startswith('"') and expression.endswith('"'):
-            value = expression[1:-1]
-            return self._convert_type(value, "string", expected_type)
+        """Evaluates literal values (string, bool, int, float) with automatic type conversion,
+           using stricter matching for strings."""
 
-        # Boolean literals
-        if expression.lower() in ("true", "false"):
-            value = expression.lower() == "true"
-            return self._convert_type(value, "bool", expected_type)
+        # --- String Literal Check (Stricter) ---
+        # Use regex to ensure ONLY a quoted string (+ optional surrounding whitespace).
+        # This pattern handles escaped quotes (\") inside the string.
+        str_match = re.fullmatch(r'\s*"((?:[^"\\]|\\.)*)"\s*', expression)
+        if str_match:
+            raw_content = str_match.group(1)  # The content inside the quotes
+            try:
+                # Use ast.literal_eval to safely evaluate the string content,
+                # correctly handling standard Python escape sequences (\n, \", \t, etc.).
+                # We reconstruct the quoted string for literal_eval.
+                evaluated_value = ast.literal_eval(
+                    '"' + raw_content.replace('"', '\\"') + '"')
+            except Exception as e:
+                # Fallback if literal_eval fails (highly unlikely for valid string literals)
+                if self.debug:
+                    print(
+                        f"  Warning: ast.literal_eval failed for string content '{raw_content}': {e}. Using raw content.")
+                evaluated_value = raw_content  # Use the raw content as a fallback
 
-        # Numeric literals
-        if re.match(r"^-?\d+(\.\d+)?$", expression):
-            if "." in expression:
-                value = float(expression)
-                return self._convert_type(value, "float", expected_type)
+            if self.debug:
+                print(
+                    f"  Literal evaluated as string: {repr(evaluated_value)}")
+            return self._convert_type(evaluated_value, "string", expected_type)
+
+        # --- Boolean Literals ---
+        if expression.lower() == "true":
+            if self.debug:
+                print("  Literal evaluated as bool: True")
+            return self._convert_type(True, "bool", expected_type)
+        if expression.lower() == "false":
+            if self.debug:
+                print("  Literal evaluated as bool: False")
+            return self._convert_type(False, "bool", expected_type)
+
+        # --- Numeric Literals (int or float) ---
+        # Use the existing helper functions _is_int, _is_float
+        if _is_int(expression):
             value = int(expression)
+            if self.debug:
+                print(f"  Literal evaluated as int: {value}")
             return self._convert_type(value, "int", expected_type)
+        if _is_float(expression):
+            value = float(expression)
+            if self.debug:
+                print(f"  Literal evaluated as float: {value}")
+            return self._convert_type(value, "float", expected_type)
 
+        # --- No Literal Match ---
+        # Return None to indicate this expression is not a simple literal.
         return None
 
     def _convert_type(self, value, source_type, target_type):
         """Enhanced type conversion system"""
-        if source_type == target_type or target_type is None:
+        if source_type == target_type or target_type is None or target_type == "any":
             return value
+        if source_type == "any":  # If source is 'any', try to guess Python type
+            source_type = _get_python_type_name(value)
 
         key = (source_type, target_type)
         if key in self.type_conversions:
             try:
-                return self.type_conversions[key](value)
-            except (ValueError, TypeError):
+                if self.debug:
+                    print(
+                        f"  Converting '{value}' ({source_type}) -> {target_type}")
+                converted = self.type_conversions[key](value)
+                if self.debug:
+                    print(f"    -> Result: '{converted}' ({target_type})")
+                return converted
+            except (ValueError, TypeError) as e:
                 raise ValueError(
-                    f"Cannot convert {value} from {source_type} to {target_type}"
+                    f"Cannot convert '{value}' from {source_type} to {target_type}: {e}"
                 )
+        # Allow conversion between int/float implicitly if no specific rule exists
+        elif source_type in ("int", "float") and target_type in ("int", "float"):
+            return float(value) if target_type == "float" else int(value)
+
+        # Allow conversion to bool - generally True unless 0, empty, or False
+        elif target_type == "bool":
+            return bool(value)
+
+        # Allow conversion to string
+        elif target_type == "string":
+            return str(value)
 
         raise ValueError(
             f"Unsupported type conversion from {source_type} to {target_type}"
         )
 
     def _evaluate_string_concatenation(self, expression):
-        """Evaluates string concatenation expressions."""
+        """
+        Evaluates string concatenation expressions (+ operator),
+        respecting variables, literals, quotes, and basic nesting.
+        """
+        # --- Debug Start ---
         if self.debug:
-            print(f"String concat vars {self.variables}")
-        parts = re.split(r"\s*\+\s*", expression)
+            print(f"  String concat executing on: '{expression}'")
+            # Show the specific variables context this evaluator instance is using
+            print(
+                f"  String concat evaluator vars ID: {id(self.variables)}, Content: {self.variables}")
+        # --- Debug End ---
+
         result = ""
+        parts = []
+        current_part = ""
+        idx = 0
+        start = 0
+        in_quotes = None  # Track the type of quote (' or ") currently active
+        nesting_depth = 0  # Track depth of brackets '[]' and parentheses '()'
+
+        # --- Robust Splitting Logic ---
+        while idx < len(expression):
+            char = expression[idx]
+
+            # Handle entering/exiting quotes
+            if char in ('"', "'"):
+                if in_quotes is None:
+                    in_quotes = char  # Enter quote block
+                elif char == in_quotes:
+                    in_quotes = None  # Exit quote block
+
+            # Track nesting level (only outside quotes)
+            elif char in ('[', '(') and in_quotes is None:
+                nesting_depth += 1
+            elif char in (']', ')') and in_quotes is None:
+                if nesting_depth > 0:  # Avoid going negative on mismatched brackets
+                    nesting_depth -= 1
+
+            # Split on '+' only if outside quotes and at the top level (nesting_depth == 0)
+            elif char == '+' and in_quotes is None and nesting_depth == 0:
+                parts.append(expression[start:idx].strip())
+                start = idx + 1  # Start next part after the '+'
+
+            idx += 1
+        # --- End of Splitting Loop ---
+
+        # Add the final part of the expression (after the last '+' or if no '+')
+        parts.append(expression[start:].strip())
+
+        # --- Debug Parts ---
+        if self.debug:
+            print(f"  String concat parts identified: {parts}")
+        # --- Debug End ---
+
+        # Handle case where splitting resulted in empty list (e.g., expression was just "+")
+        if not parts:
+            # Depending on desired behavior, could return "" or raise error.
+            # Returning "" seems reasonable for an empty/invalid concat expression.
+            return ""
+
+        # --- Evaluate Each Part ---
         for part in parts:
-            part = part.strip()
-            # Handle string literals
-            if part.startswith('"') and part.endswith('"'):
-                result += part[1:-1]
-            # Handle variables
-            elif part in self.variables:
-                value, var_type = self.variables[part]
+            part = part.strip()  # Ensure part itself has no leading/trailing whitespace
+            if not part:
+                # Skip empty parts that might result from splitting (e.g., "a + + b")
+                continue
+
+            # --- Debug Part Evaluation ---
+            if self.debug:
+                print(f"      String concat evaluating part: '{part}'")
+            # --- Debug End ---
+
+            try:
+                # Evaluate the part recursively using the *same* evaluator instance,
+                # ensuring it uses the correct variable scope (self.variables).
+                # Evaluate expecting *any* type initially.
+                value = self.evaluate(part, None)
+
+                # --- Debug Part Result ---
+                if self.debug:
+                    print(
+                        f"      Part '{part}' evaluated to: {repr(value)} (type: {_get_python_type_name(value)})")
+                # --- Debug End ---
+
+                # Append the string representation of the evaluated value
                 result += str(value)
-            # Handle other expressions
-            else:
-                try:
-                    value = self.evaluate(part, None)
-                    result += str(value)
-                except ValueError:
-                    raise ValueError(f"Invalid part in string concatenation: {part}")
+
+            except (ValueError, TypeError, IndexError, ZeroDivisionError) as e:
+                # Improve error context if a part fails to evaluate
+                raise ValueError(
+                    f"Invalid part ('{part}') within string concatenation expression '{expression}': {e}") from e
+            except Exception as e:
+                # Catch unexpected errors during part evaluation
+                raise RuntimeError(
+                    f"Unexpected error evaluating part ('{part}') in string concatenation '{expression}': {type(e).__name__}: {e}") from e
+        # --- End of Part Evaluation Loop ---
+
+        # --- Debug Final Result ---
+        if self.debug:
+            print(f"  String concat final result: '{result}'")
+        # --- Debug End ---
 
         return result
 
-    def _is_list_type(self, list_name):
-        if list_name not in self.variables or (
-            self.variables[list_name][1] != "list"
-            and self.variables[list_name][1] != "string"
-        ):
-            return False
-        return True
+    def _is_list_or_string(self, name):
+        """Checks if a variable exists and is a list or string."""
+        if name not in self.variables:
+            return False, f"Variable '{name}' not defined."
+        _, var_type = self.variables[name]
+        if var_type not in ("list", "string"):
+            return False, f"Variable '{name}' is type '{var_type}', not list or string."
+        return True, None
 
-    def _evaluate_list_operation(self, match, expected_type=None):
-        """Evaluates list append/remove/insert/replace operations."""
-        list_name, value_str, operation, extra = match.groups()
-        if not self._is_list_type(list_name):
-            raise ValueError(f"'{list_name}' is not a defined list or string.")
+    def _evaluate_list_operation(self, match):
+        """Evaluates list/string append/remove/insert/replace operations. Modifies in-place."""
+        list_name, value_expr, operation, extra_expr = match.groups()
 
-        # Get the value and type of the list/string
-        list_value, list_type = self.variables[list_name]
+        is_valid, error_msg = self._is_list_or_string(list_name)
+        if not is_valid:
+            raise ValueError(error_msg)
 
-        # Handle string literals in quotes
-        if value_str.startswith('"') and value_str.endswith('"'):
-            value = value_str[1:-1]  # Remove quotes
-        else:
-            # Evaluate the value expression
-            value = self.evaluate(value_str, None)
+        # Get the current value and type
+        current_collection, collection_type = self.variables[list_name]
+        # Make a copy if it's a list to avoid modifying original during evaluation if needed later
+        # Although, the intention seems to be modification in place. Be careful.
+        # For strings, Python strings are immutable, so assignment is needed anyway.
 
-        if operation == "a":  # Append
-            if list_type == "list":
-                list_value.append(value)
-            else:  # string
-                list_value += value
-            return list_value
-        elif operation == "r":  # Remove
-            if list_type == "list":
-                if value in list_value:
-                    list_value.remove(value)
-            else:  # string
-                list_value = list_value.replace(value, "")
-            return list_value
-        elif operation == "n":  # Insert
-            if extra is None:
-                raise ValueError("Insert operation requires a position")
-            try:
-                position = int(extra.strip())
-                if list_type == "list":
-                    # Convert to 0-based indexing
-                    list_value.insert(position - 1, value)
-                else:  # string
-                    list_value = (
-                        list_value[: position - 1] + value + list_value[position - 1 :]
-                    )
-                return list_value
-            except (ValueError, TypeError):
-                raise ValueError("Invalid position for insert operation")
-        elif operation == "p" or operation == "P":  # Replace/Replace All
-            if extra is None:
-                raise ValueError("Replace operation requires a new value")
-            # Handle string literals in quotes for the replacement value
-            if extra.strip().startswith('"') and extra.strip().endswith('"'):
-                new_value = extra.strip()[1:-1]  # Remove quotes
-            else:
-                new_value = extra.strip()
+        # Evaluate the value expression
+        # Evaluate value with no specific type expected initially
+        value = self.evaluate(value_expr, None)
 
-            if list_type == "list":
+        # Evaluate extra expression (position or replacement value) if present
+        extra_value = None
+        if extra_expr:
+            extra_value = self.evaluate(extra_expr, None)
+
+        if collection_type == "list":
+            # Operate on a copy then reassign if needed, or modify list directly?
+            # Let's modify directly for now.
+            target_list = current_collection  # Operate directly on the list
+            if operation == "a":  # Append
+                target_list.append(value)
+            elif operation == "r":  # Remove (first occurrence)
                 try:
-                    index = list_value.index(value)
-                    list_value[index] = new_value
+                    target_list.remove(value)
                 except ValueError:
-                    raise ValueError(f"Value {value} not found in list {list_name}")
-            else:  # string
-                if operation == "p":
-                    # Replace only first occurrence
-                    list_value = list_value.replace(value, new_value, 1)
-                else:
-                    list_value = list_value.replace(
-                        value, new_value
-                    )  # Replace all occurrences
-            return list_value
-        else:
-            raise ValueError(f"Invalid list operation: {operation}")
+                    print(
+                        f"Warning: Value '{value}' not found in list '{list_name}' for removal.")
+                    # Don't raise error if not found? Or should we? Let's warn for now.
+                    pass
+            elif operation == "n":  # Insert
+                if extra_value is None:
+                    raise ValueError(
+                        "Insert operation [n] requires a position argument.")
+                try:
+                    # Note: Using 1-based indexing from user perspective
+                    position = self._convert_type(
+                        extra_value, _get_python_type_name(extra_value), "int")
+                    if not (1 <= position <= len(target_list) + 1):
+                        raise ValueError(
+                            f"Insert position {position} out of range for list '{list_name}' (size {len(target_list)}). Use 1 to {len(target_list)+1}.")
+                    # Convert to 0-based for Python
+                    target_list.insert(position - 1, value)
+                except (ValueError, TypeError) as e:
+                    raise ValueError(
+                        f"Invalid position for insert operation: {e}")
+            elif operation == "p" or operation == "P":  # Replace/Replace All
+                if extra_value is None:
+                    raise ValueError(
+                        "Replace operation [p/P] requires a new value argument.")
+                new_value = extra_value  # Already evaluated
+                found = False
+                for i in range(len(target_list)):
+                    # Compare elements carefully (e.g., string vs number)
+                    # Simple string comparison for now
+                    if str(target_list[i]) == str(value):
+                        target_list[i] = new_value
+                        found = True
+                        if operation == "p":  # Replace only first
+                            break
+                if not found:
+                    print(
+                        f"Warning: Value '{value}' not found in list '{list_name}' for replacement.")
 
-    def _evaluate_list_length(self, match, expected_type="int"):
+            # Return the modified list (though it was modified in-place)
+            return target_list
+
+        elif collection_type == "string":
+            target_string = current_collection
+            # Convert value and extra_value to string for string operations
+            value_str = str(value)
+            extra_value_str = str(
+                extra_value) if extra_value is not None else None
+
+            if operation == "a":  # Append
+                target_string += value_str
+            elif operation == "r":  # Remove (all occurrences)
+                target_string = target_string.replace(value_str, "")
+            elif operation == "n":  # Insert
+                if extra_value is None:
+                    raise ValueError(
+                        "Insert operation [n] requires a position argument.")
+                try:
+                    # Note: Using 1-based indexing from user perspective
+                    position = self._convert_type(
+                        extra_value, _get_python_type_name(extra_value), "int")
+                    if not (1 <= position <= len(target_string) + 1):
+                        raise ValueError(
+                            f"Insert position {position} out of range for string '{list_name}' (length {len(target_string)}). Use 1 to {len(target_string)+1}.")
+                    # 0-based slice
+                    target_string = target_string[:position - 1] + \
+                        value_str + target_string[position - 1:]
+                except (ValueError, TypeError) as e:
+                    raise ValueError(
+                        f"Invalid position for insert operation: {e}")
+            elif operation == "p":  # Replace first
+                if extra_value_str is None:
+                    raise ValueError(
+                        "Replace operation [p] requires a new value argument.")
+                target_string = target_string.replace(
+                    value_str, extra_value_str, 1)
+            elif operation == "P":  # Replace all
+                if extra_value_str is None:
+                    raise ValueError(
+                        "Replace operation [P] requires a new value argument.")
+                target_string = target_string.replace(
+                    value_str, extra_value_str)
+
+            # Return the new string (strings are immutable)
+            return target_string
+        else:
+            # Should not happen due to initial check, but added for safety
+            raise ValueError(f"'{list_name}' is not a list or string.")
+
+    def _evaluate_list_length(self, match):
         list_name = match.group(1)
-        if not self._is_list_type(list_name):
-            raise ValueError(f"'{list_name}' is not a defined list.")
+        is_valid, error_msg = self._is_list_or_string(list_name)
+        if not is_valid:
+            raise ValueError(error_msg)
         length = len(self.variables[list_name][0])
         if self.debug:
-            print(f" List length result: {length}")
+            print(f"  List/String length result: {length}")
         return length
 
-    def _evaluate_list_random(self, match, expected_type="int"):
+    def _evaluate_list_random(self, match):
         list_name = match.group(1)
-        if not self._is_list_type(list_name):
-            raise ValueError(f"'{list_name}' is not a defined list.")
-        return random.choice(self.variables[list_name][0])
-
-    def _evaluate_list_indexing(self, match, expected_type=None):
-        """Evaluates list indexing operations."""
-        list_name, index_expression = match.groups()
-        if not self._is_list_type(list_name):
-            raise ValueError(f"'{list_name}' is not a defined list.")
-        index = self.evaluate(index_expression.strip(), "int")
-        if not isinstance(index, int):
+        is_valid, error_msg = self._is_list_or_string(list_name)
+        if not is_valid:
+            raise ValueError(error_msg)
+        collection = self.variables[list_name][0]
+        if not collection:
             raise ValueError(
-                f"Index must evaluate to an integer. Got: {type(index).__name__}"
+                f"Cannot get random element from empty list/string '{list_name}'")
+        choice = random.choice(collection)
+        if self.debug:
+            print(f"  List/String random choice: {choice}")
+        return choice
+
+    def _evaluate_list_indexing(self, match):
+        """Evaluates list/string indexing operations. Uses 1-based indexing for user."""
+        list_name, index_expression = match.groups()
+        is_valid, error_msg = self._is_list_or_string(list_name)
+        if not is_valid:
+            raise ValueError(error_msg)
+
+        # Evaluate the index expression, expecting an integer
+        index_val = self.evaluate(index_expression.strip(), "int")
+        if not isinstance(index_val, int):
+            # This should ideally be caught by evaluate requesting "int", but double-check
+            raise ValueError(
+                f"Index must evaluate to an integer. Got: {type(index_val).__name__}"
             )
+
+        collection = self.variables[list_name][0]
+        # Convert 1-based user index to 0-based Python index
+        zero_based_index = index_val - 1
+
         try:
-            return self.variables[list_name][0][index - 1]
+            item = collection[zero_based_index]
+            if self.debug:
+                print(f"  List/String index [{index_val}] -> '{item}'")
+            return item
         except IndexError:
-            print(f"Warning: Index {index} out of range for list {list_name}")
-            return None  # Or raise the exception, depending on the desired behavior
+            # Return None for out-of-bounds access, as per original code's warning
+            print(
+                f"Warning: Index {index_val} out of range for {self.variables[list_name][1]} '{list_name}' (size {len(collection)})")
+            return None
 
-    def _evaluate_list_finding(self, match, expected_type=None):
-        """Evaluates list indexing operations."""
+    def _evaluate_list_finding(self, match):
+        """Evaluates list/string finding operations. Returns 1-based index or 0 if not found."""
         list_name, value_expression = match.groups()
+        is_valid, error_msg = self._is_list_or_string(list_name)
+        if not is_valid:
+            raise ValueError(error_msg)
 
-        if not self._is_list_type(list_name):
-            raise ValueError(f"'{list_name}' is not a defined list.")
+        # Evaluate the value to find
+        value_to_find = self.evaluate(value_expression.strip(), None)
 
-        value = self.evaluate(value_expression.strip(), None)
         if self.debug:
-            print(f"List name: {list_name}")
-            print(f"Value expression: {value_expression}")
-            print(f"Value: {value}")
+            print(
+                f"  Finding value '{value_to_find}' in {self.variables[list_name][1]} '{list_name}'")
 
-        list_to_search = self.variables[list_name][0]
-        for i, item in enumerate(list_to_search):
-            if str(item) == str(value):
-                # Return the 1-based index of the first occurrence of the value
-                return i + 1
-        if self.debug:
-            print(f"Warning: Value {value} not found in list {list_name}")
-        return 0
-        # Or raise the exception, depending on the desired behavior
+        collection = self.variables[list_name][0]
 
-    def _evaluate_type_conversion(self, match, expected_type=None):
-        """Evaluates type conversion expressions."""
-        var_name, target_type = match.groups()
-        if var_name not in self.variables:
-            # Try to evaluate the expression first
-            try:
-                value = self.evaluate(var_name, None)
-                return self._convert_type(
-                    value, type(value).__name__.lower(), target_type
-                )
-            except ValueError:
-                raise ValueError(f"Variable or expression '{var_name}' not defined.")
+        try:
+            # Python's index() method works for both lists and strings
+            # We need to handle potential type differences during search
+            # Simple approach: convert items to string for comparison
+            found_index = -1
+            str_value_to_find = str(value_to_find)
+            for i, item in enumerate(collection):
+                if str(item) == str_value_to_find:
+                    found_index = i
+                    break
 
-        source_value, source_type = self.variables[var_name]
-        return self._convert_type(source_value, source_type, target_type)
+            if found_index != -1:
+                result_index = found_index + 1  # Convert to 1-based index for user
+                if self.debug:
+                    print(f"    Found at 1-based index: {result_index}")
+                return result_index
+            else:
+                if self.debug:
+                    print(f"    Value '{value_to_find}' not found.")
+                return 0  # Return 0 if not found
+
+        except ValueError:
+            # Should not happen with the loop above, but keep as fallback
+            if self.debug:
+                print(f"    Value '{value_to_find}' not found (error).")
+            return 0
+
+    def _evaluate_type_conversion(self, match, expected_type):  # Added expected_type
+        """Evaluates explicit type conversion expressions like 'expr :> type'."""
+        expr_to_convert, target_type = match.groups()
+
+        if target_type not in Interpreter.supported_types:  # Access supported types statically
+            raise ValueError(
+                f"Unsupported target type for conversion: {target_type}")
+
+        # First, evaluate the inner expression without a target type
+        source_value = self.evaluate(expr_to_convert, None)
+        source_type = _get_python_type_name(
+            source_value)  # Get type from evaluated value
+
+        # Now, perform the explicit conversion
+        converted_value = self._convert_type(
+            source_value, source_type, target_type)
+
+        # Finally, convert to the overall expected type if one was provided
+        return self._convert_type(converted_value, target_type, expected_type)
 
     def _evaluate_rpn(self, expression):
         """Evaluates RPN arithmetic expressions."""
+        if self.debug:
+            print(f"  Evaluating RPN: '{expression}'")
         stack = []
         tokens = expression.split()
 
         for token in tokens:
-            # Check for numeric literals, accounting for negative signs and decimals
-            if re.match(r"^-?\d+(\.\d*)?$", token):  # Improved regex
-                try:
-                    if "." in token:
-                        stack.append(float(token))
-                    else:
-                        stack.append(int(token))
-                except ValueError:  # Could happen if token is something like "1.a"
-                    raise ValueError(f"Invalid number literal: {token}")
+            token = token.strip()
+            if not token:
+                continue
+
+            # Use literal evaluation for numbers
+            literal_val = self._evaluate_literal(
+                token, None)  # Try to parse as literal first
+            if isinstance(literal_val, (int, float)):
+                stack.append(literal_val)
+                if self.debug:
+                    print(f"    RPN Push (literal): {literal_val}")
             elif token in self.variables:
                 var_value, var_type = self.variables[token]
                 if var_type in ("int", "float"):
                     stack.append(var_value)
+                    if self.debug:
+                        print(
+                            f"    RPN Push (variable '{token}'): {var_value}")
                 else:
-                    raise ValueError(
-                        f"Variable '{token}' is not numeric (type: {var_type})"
+                    raise TypeError(  # Use TypeError for RPN type issues
+                        f"Variable '{token}' is not numeric (type: {var_type}) in RPN expression"
                     )
-            elif token in ("+", "-", "*", "/", "%"):
+            # Added ** and !/ from original code
+            elif token in ("+", "-", "*", "/", "%", "**", "!/"):
                 if len(stack) < 2:
-                    raise ValueError(f"Insufficient operands for operator '{token}'")
-                try:
-                    operand2 = stack.pop()
-                    operand1 = stack.pop()
-                except IndexError:
-                    raise ValueError("Not enough operands on stack")
+                    raise IndexError(  # Use IndexError for stack underflow
+                        f"Insufficient operands for RPN operator '{token}'"
+                    )
+                operand2 = stack.pop()
+                operand1 = stack.pop()
+                if self.debug:
+                    print(f"    RPN Op: {operand1} {token} {operand2}")
+
+                # Perform operation
+                if token == "+":
+                    result = operand1 + operand2
+                elif token == "-":
+                    result = operand1 - operand2
+                elif token == "*":
+                    result = operand1 * operand2
+                elif token == "**":
+                    result = operand1 ** operand2
+                elif token == "/":
+                    if operand2 == 0:
+                        raise ZeroDivisionError("RPN Division by zero")
+                    result = operand1 / operand2  # Keep float for division
+                elif token == "%":
+                    if operand2 == 0:
+                        raise ZeroDivisionError("RPN Modulo by zero")
+                    result = operand1 % operand2
+                elif token == "!/":
+                    if operand2 == 0:
+                        raise ZeroDivisionError("RPN Integer division by zero")
+                    result = operand1 // operand2
+                else:
+                    # Should not happen
+                    raise ValueError(f"RPN: Unknown operator '{token}'")
+
+                stack.append(result)
+                if self.debug:
+                    print(f"      = {result}")
 
-                try:
-                    if token == "+":
-                        stack.append(operand1 + operand2)
-                    elif token == "-":
-                        stack.append(operand1 - operand2)
-                    elif token == "*":
-                        stack.append(operand1 * operand2)
-                    elif token == "/":
-                        if operand2 == 0:
-                            raise ZeroDivisionError("Division by zero")
-                        stack.append(operand1 / operand2)
-                    elif token == "%":
-                        if operand2 == 0:
-                            raise ZeroDivisionError("Modulo by zero")
-                        stack.append(operand1 % operand2)
-                except TypeError:
-                    raise ValueError("Invalid operand types for operator")
             else:
-                raise ValueError(f"Invalid RPN token: {token}")
+                raise ValueError(f"Invalid RPN token: '{token}'")
 
         if len(stack) != 1:
-            raise ValueError("Invalid RPN expression")
+            raise ValueError(f"Invalid RPN expression, final stack: {stack}")
 
-        return stack.pop()
+        final_result = stack.pop()
+        if self.debug:
+            print(f"  RPN Result: {final_result}")
+        return final_result
 
-    def _evaluate_boolean_expression(self, match, expected_type="bool"):
-        """Evaluates non-RPN boolean expressions."""
-        if isinstance(match, str):
-            expression = match
-
-        else:
-            if len(match.groups()) == 1:
-                sub_expr = match.group(1).strip()
-                result = self.evaluate(sub_expr, "bool")
-                return not result
-            left_expression, operator, right_expression = match.groups()
-            expression = f"{left_expression} {operator} {right_expression}"
-
-        if expression.lower() == "true":
-            return True
-        elif expression.lower() == "false":
-            return False
-
-        match = re.match(r"(.+)\s*(@\$@|#\$#|[<>]=?|&&|&\$\$&)\s*(.+)", expression)
-        if not match:
-            raise ValueError(f"Invalid boolean expression: {expression}")
+    def _evaluate_boolean_negation(self, match):
+        """Handles prefix boolean negation '~@ expr'"""
+        sub_expr = match.group(1).strip()
+        # Evaluate the sub-expression, expecting a boolean
+        value = self.evaluate(sub_expr, "bool")
+        return not value
 
+    def _evaluate_boolean_expression_infix(self, match):
+        """Evaluates infix boolean expressions (e.g., a && b, x < 5)."""
         left_expression, operator, right_expression = match.groups()
+
+        # Evaluate operands *without* assuming a type initially
         left_val = self.evaluate(left_expression.strip(), None)
         right_val = self.evaluate(right_expression.strip(), None)
 
-        left_type = type(left_val).__name__
-        right_type = type(right_val).__name__
+        left_type = _get_python_type_name(left_val)
+        right_type = _get_python_type_name(right_val)
 
-        if operator in ("&&", "&$$&"):
-            if left_type != right_type and not (
-                left_type in ("int", "float") and right_type in ("int", "float")
-            ):
-                raise ValueError(
-                    f"Type mismatch: Cannot compare {left_type} with {right_type}"
-                )
-        elif operator in ("<", ">", "<=", ">="):
-            if not (
-                (left_type in ("int", "float") and right_type in ("int", "float"))
-                or (left_type == right_type == "string")
-            ):
-                raise ValueError(
-                    f"Type mismatch: Cannot compare {left_type} with {right_type} using {operator}"
-                )
+        if self.debug:
+            print(
+                f"  Boolean Infix: '{left_val}' ({left_type}) {operator} '{right_val}' ({right_type})")
+
+        # Logical operators (AND, OR) - evaluate operands as boolean
+        if operator == "@$@":  # Logical AND
+            return bool(left_val) and bool(right_val)
+        elif operator == "#$#":  # Logical OR
+            return bool(left_val) or bool(right_val)
+
+        # Comparison operators
+        # Try numeric comparison first if both look numeric or are numeric
+        can_compare_numeric = (left_type in ("int", "float") or _is_numeric_string(left_expression.strip())) and \
+                              (right_type in ("int", "float")
+                               or _is_numeric_string(right_expression.strip()))
+
+        if can_compare_numeric:
+            try:
+                # Convert to float for comparison to handle int/float mix
+                num_left = self._convert_type(left_val, left_type, "float")
+                num_right = self._convert_type(right_val, right_type, "float")
+
+                if operator == "&&":
+                    return num_left == num_right
+                elif operator == "&$$&":
+                    return num_left != num_right
+                elif operator == "<":
+                    return num_left < num_right
+                elif operator == ">":
+                    return num_left > num_right
+                elif operator == "<=":
+                    return num_left <= num_right
+                elif operator == ">=":
+                    return num_left >= num_right
+                # If we got here with a comparison operator, something's wrong
+                # Fall through to string comparison? Or raise error? Let's fall through for now.
+            except ValueError:
+                # If conversion to float fails, fall through to string comparison
+                pass
+
+        # If not comparable as numbers, compare as strings
+        str_left = str(left_val)
+        str_right = str(right_val)
 
         if operator == "&&":
-            if isinstance(left_val, (int, float)) and isinstance(
-                right_val, (int, float)
-            ):
-                return float(left_val) == float(right_val)
-            return str(left_val) == str(right_val)
-        elif operator == "@$@":
-            return bool(left_val) and bool(right_val)
-        elif operator == "#$#":
-            return bool(left_val) or bool(right_val)
+            return str_left == str_right
         elif operator == "&$$&":
-            if isinstance(left_val, (int, float)) and isinstance(
-                right_val, (int, float)
-            ):
-                return float(left_val) != float(right_val)
-            return str(left_val) != str(right_val)
+            return str_left != str_right
+        # For strings, <, >, <=, >= perform lexicographical comparison
         elif operator == "<":
-            if isinstance(left_val, (int, float)) and isinstance(
-                right_val, (int, float)
-            ):
-                return float(left_val) < float(right_val)
-            return str(left_val) < str(right_val)
+            return str_left < str_right
         elif operator == ">":
-            if isinstance(left_val, (int, float)) and isinstance(
-                right_val, (int, float)
-            ):
-                return float(left_val) > float(right_val)
-            return str(left_val) > str(right_val)
+            return str_left > str_right
         elif operator == "<=":
-            if isinstance(left_val, (int, float)) and isinstance(
-                right_val, (int, float)
-            ):
-                return float(left_val) <= float(right_val)
-            return str(left_val) <= str(right_val)
+            return str_left <= str_right
         elif operator == ">=":
-            if isinstance(left_val, (int, float)) and isinstance(
-                right_val, (int, float)
-            ):
-                return float(left_val) >= float(right_val)
-            return str(left_val) >= str(right_val)
+            return str_left >= str_right
+        else:
+            raise ValueError(f"Unsupported boolean operator: {operator}")
 
-    def _evaluate_list_literal(self, match, expected_type):
-        """Evaluates list literal expressions like [1, 2, "hello", x]"""
-        if expected_type not in ("list", "string", None):
-            raise ValueError(f"Cannot evaluate list literal as type {expected_type}")
+    def _evaluate_list_literal(self, match):
+        """Evaluates list literal expressions like [1, 2, "hello", x] using ast.literal_eval"""
+        list_str = match.group(0)
 
-        # Extract the content between brackets
-        content = match.group(0)[1:-1].strip()
+        if self.debug:
+            print(f"  Evaluating list literal: {list_str}")
 
-        # Handle empty list
-        if not content:
-            return [] if expected_type != "string" else ""
+        # Handle empty list explicitly
+        if list_str == "[]":
+            return []
 
-        # Split by commas, handling nested structures
+        # Need to replace variables within the list string before using literal_eval
+        # This is complex and potentially unsafe if not done carefully.
+        # A simple substitution might work for basic cases, but fails with nested structures or strings containing variable names.
+
+        # --- Alternative: Manual Parsing (Adapted from original, improved) ---
+        content = list_str[1:-1].strip()
         elements = []
-        current = ""
-        bracket_count = 0
-        quote_char = None
+        current_element = ""
+        bracket_depth = 0
+        in_quotes = None  # Can be ' or "
 
         for char in content:
-            if char in ('"', "'") and not quote_char:
-                quote_char = char
-            elif char == quote_char:
-                quote_char = None
-            elif char == "[":
-                bracket_count += 1
-            elif char == "]":
-                bracket_count -= 1
-            elif char == "," and bracket_count == 0 and not quote_char:
-                elements.append(current.strip())
-                current = ""
+            if char in ('"', "'") and in_quotes is None:
+                in_quotes = char
+                current_element += char
+            elif char == in_quotes:
+                in_quotes = None
+                current_element += char
+            elif char == '[' and not in_quotes:
+                bracket_depth += 1
+                current_element += char
+            elif char == ']' and not in_quotes:
+                bracket_depth -= 1
+                current_element += char
+            elif char == ',' and bracket_depth == 0 and not in_quotes:
+                elements.append(current_element.strip())
+                current_element = ""
+            else:
+                current_element += char
+
+        if current_element:
+            elements.append(current_element.strip())
+
+        # Evaluate each element recursively
+        result_list = []
+        for elem_expr in elements:
+            if not elem_expr:
                 continue
-            current += char
-
-        if current:
-            elements.append(current.strip())
-
-        # Evaluate each element
-        result = []
-        for element in elements:
             try:
-                # Recursively evaluate each element
-                value = self.evaluate(element, None)
-                result.append(value)
+                value = self.evaluate(elem_expr, None)  # Evaluate element
+                result_list.append(value)
             except ValueError as e:
-                raise ValueError(f"Invalid list element: {element}. {str(e)}")
+                raise ValueError(
+                    f"Invalid list element expression: '{elem_expr}'. {e}")
 
-        if expected_type == "string":
-            return "".join(str(x) for x in result)
-        return result
+        if self.debug:
+            print(f"  Evaluated list literal result: {result_list}")
+        return result_list
 
-    def _evaluate_literals_and_variables(self, expression, expected_type):
-        if expression.startswith('"') and expression.endswith('"'):
-            return expression[1:-1]
-        elif expression.startswith("[") and expression.endswith("]"):
-            try:
-                # Handle empty list
-                if expression == "[]":
-                    return []
-                elements = [x.strip() for x in expression[1:-1].split(",") if x.strip()]
-                if self.debug:
-                    print(f" List literal: {elements}")
-                return elements
-            except ValueError:
-                raise ValueError(f"Invalid list literal: {expression}")
-        elif expression.lower() == "true":
-            return True
-        elif expression.lower() == "false":
-            return False
-        elif expression.isdigit():
-            return int(expression)
-        elif re.match(r"^[+-]?\d+(\.\d+)?$", expression):  # improved float regex
-            return float(expression)
-        elif expression in self.variables:
-            var_value, _ = self.variables[expression]
-            return var_value
-        else:
-            raise ValueError(f"Invalid expression or undefined variable: {expression}")
+        # --- AST Literal Eval (Safer but less flexible) ---
+        # try:
+        #     # ast.literal_eval is safer than eval() but only handles literals
+        #     # It CANNOT handle variables directly. We would need preprocessing.
+        #     # For now, let's stick to the manual parsing which allows variables.
+        #     # evaluated_list = ast.literal_eval(list_str)
+        #     # if isinstance(evaluated_list, list):
+        #     #     return evaluated_list
+        #     # else:
+        #     #     raise ValueError("Expression evaluated to non-list type via literal_eval")
+        #     pass # Placeholder if using ast
+        # except (ValueError, SyntaxError, TypeError) as e:
+        #      raise ValueError(f"Invalid list literal syntax: {list_str}. Error: {e}")
+
+
+# --- Helper functions ---
+def _is_int(s):
+    if not isinstance(s, str):
+        s = str(s)
+    return re.fullmatch(r"-?\d+", s.strip())
+
+
+def _is_float(s):
+    if not isinstance(s, str):
+        s = str(s)
+    # Basic check, allows ".5", "5." etc.
+    return re.fullmatch(r"-?(\d+(\.\d*)?|\.\d+)", s.strip())
+
+
+def _is_numeric_string(s):
+    """Checks if a string represents an int or a float."""
+    return _is_int(s) or _is_float(s)
+
+
+def _get_python_type_name(value):
+    """Maps Python types to the language's type names."""
+    if isinstance(value, bool):
+        return "bool"  # Check bool before int
+    if isinstance(value, int):
+        return "int"
+    if isinstance(value, float):
+        return "float"
+    if isinstance(value, str):
+        return "string"
+    if isinstance(value, list):
+        return "list"
+    if value is None:
+        return "void" 
+    return "any" 
+
+
+def _raise(exception):
+    """Helper to raise exceptions inside lambdas."""
+    raise exception
+
+# ------------------------------------------------------------
+
+# Part 4: `Interpreter` Class (with fixes)
 
 
 class Interpreter:
+    # Class attribute for supported types
+    supported_types = ["int", "float", "string",
+                       "list", "bool", "any", "void"]  # Added 'any'
+
     def __init__(self, debug=False, debug_show=False):
-        self.variables = {}
-        self.functions = {}  # Store defined functions
-        self.labels = {}
-        self.supported_types = ["int", "float", "string", "list", "bool", "set", "void"]
-        self.expression_evaluator = ExpressionEvaluator(self.variables, debug)
+        self.variables: Dict[str, tuple[Any, str]] = {}  # Global variables
+        self.functions: Dict[str, Function] = {}  # Store defined functions
+        self.labels: Dict[str, int] = {}  # Label name -> line number (1-based)
+        self.expression_evaluator = ExpressionEvaluator(
+            self.variables, self.functions, interpreter=self, debug=debug)  # Pass functions dict
         self.debug = debug
         self.debug_show = debug_show
-        self.return_value = None  # Store function return values
+        # No global return_value needed if scope is handled correctly
 
     def run(self, filepath):
         """Runs the interpreter on the given script file."""
         try:
             with open(filepath, "r") as file:
                 lines = file.readlines()
-                for i, line in enumerate(lines):
-                    if line.startswith(LABEL_KEYWORD):
-                        # match LBL name;
-                        match = re.match(r"LBL\s+([a-zA-Z_]\w*)\s*;", line)
-                        if match:
-                            label_name = match.group(1)
-                            lineNumber = i
-                            self.labels[label_name] = lineNumber + 1
-                        else:
-                            raise ValueError(f"Invalid label definition: {line}")
-                self.execute_lines(lines)
+            # Pre-scan for labels and function definitions
+            self.pre_scan(lines)
+            # Execute lines
+            self.execute_block(lines)
         except FileNotFoundError:
             print(f"Error: File '{filepath}' not found.")
+        except ValueError as e:
+            # Catch errors propagated from execute_block/execute_line
+            print(f"Runtime Error: {e}")
+            # Optionally print line number if available/tracked
         except Exception as e:
-            print(f"Error: {str(e)}")
+            print(f"Unexpected Error: {type(e).__name__}: {e}")
+            # Consider adding traceback for unexpected errors during debugging
+            # import traceback
+            # traceback.print_exc()
 
     def run_repl(self):
         """Run the interpreter in REPL (Read-Eval-Print Loop) mode."""
         print("Pepper Programming Language REPL")
         print("Type 'exit' to quit, 'help' for commands")
-        print("Variables:", end=" ")
+        # Consider adding 'vars' command instead of printing always
+        # print("Type 'vars' to see current variables.")
 
         while True:
-            try:
-                # Show current variables as context
-                if self.variables:
-                    vars_str = ", ".join(
-                        f"{k}: {v[1]}" for k, v in self.variables.items()
-                    )
-                    print(f"\nVariables: {vars_str}")
+            # Show current variables for context (optional)
+            # if self.variables:
+            #     vars_str = ", ".join(
+            #         f"{k}: {v[1]}" for k, v in self.variables.items()
+            #     )
+            #     print(f"\nVariables: {vars_str}")
 
-                # Get input
+            try:
                 line = input(">>> ").strip()
 
-                # Handle special commands
+                if not line:
+                    continue
                 if line.lower() == "exit":
                     break
                 elif line.lower() == "help":
                     self._show_help()
                     continue
+                elif line.lower() == "vars":
+                    if self.variables:
+                        print("Variables:")
+                        for k, (v, t) in self.variables.items():
+                            print(f"  {k}: {t} = {repr(v)}")
+                    else:
+                        print("No variables defined.")
+                    continue
                 elif line.lower() == "clear":
                     self.variables.clear()
-                    print("All variables cleared")
-                    continue
-                elif not line:
+                    # Also clear functions in REPL? Maybe not.
+                    self.functions.clear()
+                    self.labels.clear()
+                    print("Global variables cleared.")
                     continue
 
-                # Execute the line
-                self.execute_lines([line])
+                # Pre-scan and execute the single line
+                # REPL doesn't easily support multi-line functions or jumps
+                # We can try executing directly, but complex statements might fail
+                if LABEL_KEYWORD in line or "::(" in line or GOTO_KEYWORD in line or IF_KEYWORD in line or FOR_KEYWORD in line or WHILE_KEYWORD in line:
+                    print(
+                        "Warning: Multi-line constructs (functions, labels, loops, complex ifs) have limited support in REPL.")
+                try:
+                    # Update evaluator's variable view
+                    self.expression_evaluator.variables = self.variables
+                    self.expression_evaluator.functions = self.functions
+                    # Execute in global scope
+                    result = self.execute_line(line, 0, self.variables)
+                    if result is not None:  # e.g., SHOW command prints, function call returns
+                        # Don't print result automatically unless it's an expression?
+                        # Let SHOW handle printing.
+                        pass
+                except ValueError as e:
+                    print(f"Error: {e}")
+                except Exception as e:
+                    print(f"Unexpected Error: {type(e).__name__}: {e}")
 
-            except Exception as e:
-                print(f"Error: {str(e)}")
+            except EOFError:  # Handle Ctrl+D
+                break
+            except KeyboardInterrupt:  # Handle Ctrl+C
+                print("\nKeyboardInterrupt")
+                # Optionally offer to exit or clear state
+
+        print("Exiting REPL.")
 
     def _show_help(self):
         """Show help information for REPL mode."""
         help_text = """
-Available Commands:
-    LET x: type = value    - Declare a variable
-    REAS x = value        - Reassign a variable
-    SHOW expression       - Display a value
-    exit                  - Exit REPL
-    help                  - Show this help
-    clear                 - Clear all variables
+Pepper REPL Help:
 
-Types:
-    int     - Integer numbers
-    float   - Decimal numbers
-    string  - Text in quotes
-    bool    - True/False values
-    list    - Lists of values
+Commands:
+  LET x: type = value    - Declare a global variable (e.g., LET count:int = 0)
+  REAS x = value        - Reassign a global variable (e.g., REAS count = count + 1)
+  SHOW(expression)      - Evaluate expression and print the result (e.g., SHOW(count * 2))
+  ? seed_value          - Set the random number generator seed (e.g., ? 12345 or ? my_seed_string)
+  vars                  - Show currently defined global variables and their values.
+  clear                 - Clear all global variables.
+  exit                  - Exit the REPL.
+  help                  - Show this help message.
 
-List Operations:
-    [a]     - Append
-    [r]     - Remove
-    [n]     - Insert at position
-    [p]     - Replace first occurrence
-    [P]     - Replace all occurrences
-    [l]     - Get length
-    [i]     - Get item at index
-    [f]     - Find index of value
-    [?]     - Get random value from list
+Types: int, float, string, bool, list, any, void
+
+Expressions:
+  Literals: 10, 3.14, "hello", true, false, [1, "a", true]
+  Variables: x, count
+  Input: INPT("Prompt")
+  Type Convert: expr :> type (e.g., "123" :> int)
+  Arithmetic (RPN): 5 3 + (space-separated Reverse Polish Notation)
+                     ? (evaluates to random float in RPN)
+  Boolean: a && b (equal), a &$$& b (not equal), a @$@ b (and), a #$# b (or)
+           a < b, a > b, a <= b, a >= b
+           ~@ expr (negation)
+  String Concat: "Hello " + name + "!"
+  List Ops (var is list/string):
+    var value [a]     - Append value
+    var value [r]     - Remove first occurrence of value
+    var value [n] pos - Insert value at 1-based position 'pos'
+    var value [p] new - Replace first occurrence of 'value' with 'new'
+    var value [P] new - Replace ALL occurrences of 'value' with 'new'
+    var [l]           - Get length
+    var [i] index     - Get item at 1-based 'index'
+    var [f] value     - Find 1-based index of 'value' (0 if not found)
+    var [?]           - Get random element
+
+Notes:
+  - REPL primarily operates on global variables.
+  - Multi-line blocks (IF, FOR, WHILE, functions) have limited support.
+  - Statements generally don't produce output unless using SHOW.
 """
         print(help_text)
 
-    def execute_lines(self, lines):
-        """Executes the lines of code."""
+    def pre_scan(self, lines: List[str]):
+        """Scans lines for labels and function definitions before execution."""
+        self.labels.clear()
+        self.functions.clear()
         line_number = 0
-        skip_lines = 0
-        inside_if = False
-        loop_stack = []
-
         while line_number < len(lines):
             line = lines[line_number].split("%%")[0].strip()
-
-            if skip_lines > 0:
-                skip_lines -= 1
-                if self.debug:
-                    print(f"Skipping line {line_number + 1}: {line}")
+            if not line:
                 line_number += 1
                 continue
 
+            # Find Labels
+            if line.startswith(LABEL_KEYWORD):
+                match = re.match(r"LBL\s+([a-zA-Z_]\w*)\s*;", line)
+                if match:
+                    label_name = match.group(1)
+                    if label_name in self.labels:
+                        raise ValueError(
+                            f"Duplicate label '{label_name}' defined on line {line_number + 1}")
+                    # Store 1-based line number for GOTO convenience
+                    self.labels[label_name] = line_number + 1
+                    if self.debug:
+                        print(
+                            f"Found label '{label_name}' at line {line_number + 1}")
+                else:
+                    # Raise error during pre-scan for invalid label syntax
+                    raise ValueError(
+                        f"Invalid label definition on line {line_number + 1}: {line}")
+                line_number += 1
+            # Find Function Definitions
+            elif "::(" in line:  # Potential function start
+                try:
+                    lines_in_func = self.handle_function_declaration(
+                        lines, line_number, store_function=True)
+                    # Skip the entire function body during pre-scan
+                    line_number += lines_in_func + 1  # +1 to move past the return line
+                except ValueError as e:
+                    # Propagate errors found during function declaration parsing
+                    raise ValueError(
+                        f"Error in function definition near line {line_number + 1}: {e}")
+            else:
+                line_number += 1
+        if self.debug:
+            print(
+                f"Pre-scan complete. Labels: {self.labels}, Functions: {list(self.functions.keys())}")
+
+    def execute_block(self, lines: List[str], local_vars: Optional[Dict[str, tuple[Any, str]]] = None) -> Any:
+        """
+        Executes a block of lines (main script or function body).
+        Manages execution flow (loops, ifs, goto).
+        Returns the value from a RETURN statement, if encountered.
+        """
+        current_vars = local_vars if local_vars is not None else self.variables
+        # Create a new evaluator instance for this block, sharing functions but using current_vars
+        evaluator = ExpressionEvaluator(
+            current_vars, self.functions, self, self.debug)
+
+        line_ptr = 0  # 0-based index for line execution
+        max_lines = len(lines)
+        # Stores (type, start_line_ptr, <optional_loop_var>) for loops
+        loop_stack = []
+        conditional_stack = []  # Helps manage nested IF/ELIF/ELSE state
+
+        while 0 <= line_ptr < max_lines:
+            line = lines[line_ptr].split("%%")[0].strip()
+            current_line_num = line_ptr + 1  # 1-based for messages
+
+            # Skip empty lines, comments, labels (already processed), and function defs (already processed)
             if not line or line.startswith("%%") or line.startswith(LABEL_KEYWORD):
-                if self.debug:
-                    print(f"Skipping line {line_number + 1}: {line}")
-                line_number += 1
+                line_ptr += 1
                 continue
+            # Also skip function definition lines identified during pre-scan (simplistic check)
+            if "::(" in line and line.endswith("->"):
+                # Need a robust way to skip the whole function body here
+                # Let's rely on handle_function_declaration to calculate skip count
+                try:
+                    lines_to_skip = self.handle_function_declaration(
+                        lines, line_ptr, store_function=False)
+                    line_ptr += lines_to_skip + 1  # Skip body and return line
+                    continue
+                except ValueError:
+                    # Ignore errors here, pre-scan should have caught them
+                    line_ptr += 1
+                    continue
 
             if self.debug:
-                print(f"Processing line {line_number + 1}: {line}")
+                print(f"\n[Exec Line {current_line_num}]> {line}")
+                if current_vars != self.variables:  # If in function scope
+                    print(f"  Local Vars: {current_vars}")
 
             try:
-                if line.startswith(GOTO_KEYWORD):
-                    # Handle GOTO statement with optional condition
-                    match = re.match(r"GOTO\s+(\w+)\s*;(.+)?", line)
-                    target_line = 0
-                    if not match:
-                        raise ValueError(f"Invalid GOTO statement: {line}")
-                    target = match.group(1)
-                    if target.isdigit():
-                        target_line = int(match.group(1))
+                if line.startswith('?'): # Quick check before regex
+                    seed_match = re.match(r"\?\s+(.+)", line)
+                    if seed_match:
+                        seed_value_str = seed_match.group(1).strip()
+                        try:
+                            # Attempt conversion to int first, as it's common for seeds
+                            seed_value_for_func = int(seed_value_str)
+                            random.seed(seed_value_for_func)
+                            if self.debug: print(f"  Seeded random generator with int: {seed_value_for_func}")
+                        except ValueError:
+                            # If int conversion fails, use the string itself.
+                            # random.seed() accepts various hashable types.
+                            seed_value_for_func = seed_value_str
+                            random.seed(seed_value_for_func)
+                            if self.debug: print(f"  Seeded random generator with string: '{seed_value_for_func}'")
 
+                        line_ptr += 1 # Move to next line
+                        continue # Finished processing the seed command for this line
                     else:
-                        label_line = self.labels.get(target)
-                        if not label_line:
-                            print(f"Label {target} not found")
-                        else:
-                            if self.debug:
-                                print(f"Jumping to label {target} at line {label_line}")
-                            target_line = label_line
+                        # Handle cases like just "?" or "?seed" (no space/value)
+                        raise ValueError("Invalid seed syntax. Expected '? <seed_value>'")
+                # --- Control Flow ---
+                elif line.startswith(GOTO_KEYWORD):
+                    # Condition is optional
+                    match = re.match(r"GOTO\s+(\w+)\s*(?:;\s*(.+))?", line)
+                    if not match:
+                        raise ValueError(f"Invalid GOTO syntax")
+                    target, condition = match.groups()
 
-                    condition = match.group(2)
-                    if target_line < 1 or target_line > len(lines):
-                        raise ValueError(f"Invalid line number in GOTO: {target_line}")
+                    target_line_num = -1  # 1-based target line
+                    if target.isdigit():
+                        target_line_num = int(target)
+                    elif target in self.labels:
+                        target_line_num = self.labels[target]
+                    else:
+                        raise ValueError(
+                            f"GOTO target '{target}' is not a valid line number or defined label")
 
-                    # If there's a condition, evaluate it
+                    if not (1 <= target_line_num <= max_lines):
+                        raise ValueError(
+                            f"GOTO target line number {target_line_num} is out of bounds (1-{max_lines})")
+
+                    should_jump = True  # Default to jump if no condition
                     if condition and condition.strip():
-                        should_jump = self.expression_evaluator.evaluate(
-                            condition.strip(), "bool"
-                        )
-                        if not should_jump:
-                            line_number += 1
+                        condition_value = evaluator.evaluate(
+                            condition.strip(), "bool")
+                        should_jump = bool(condition_value)
+                        if self.debug:
+                            print(
+                                f"  GOTO condition '{condition.strip()}' evaluated to {should_jump}")
+
+                    if should_jump:
+                        if self.debug:
+                            print(f"  Jumping to line {target_line_num}")
+                        # Set next line_ptr (0-based)
+                        line_ptr = target_line_num - 1
+                        continue  # Start next iteration at the target line
+                    else:
+                        # Condition false, just proceed to the next line
+                        line_ptr += 1
+                        continue
+
+                elif line.startswith(IF_KEYWORD):
+                    match = re.match(r"IF\s+(.+?)\s+DO", line)
+                    if not match:
+                        raise ValueError("Invalid IF syntax")
+                    condition = match.group(1)
+                    cond_val = evaluator.evaluate(condition, "bool")
+                    if self.debug:
+                        print(f"  IF condition '{condition}' -> {cond_val}")
+                    conditional_stack.append(
+                        {'type': 'if', 'executed': cond_val, 'line': line_ptr})
+                    if not cond_val:
+                        # Skip to the next ELIF, ELSE, or END for this IF level
+                        line_ptr = self._find_matching_conditional_end(
+                            lines, line_ptr, ['elif', 'else', 'end'])
+                        continue  # Continue execution from the found line
+
+                elif line.startswith(ELIF_KEYWORD):
+                    if not conditional_stack or conditional_stack[-1]['type'] not in ('if', 'elif'):
+                        raise ValueError("ELIF without matching IF/ELIF")
+                    match = re.match(r"ELIF\s+(.+?)\s+DO", line)
+                    if not match:
+                        raise ValueError("Invalid ELIF syntax")
+
+                    # Only evaluate if no previous block in this chain executed
+                    if conditional_stack[-1]['executed']:
+                        # Skip to the END of the current IF structure
+                        line_ptr = self._find_matching_conditional_end(
+                            lines, conditional_stack[-1]['line'], ['end'])
+                        continue
+                    else:
+                        condition = match.group(1)
+                        cond_val = evaluator.evaluate(condition, "bool")
+                        if self.debug:
+                            print(
+                                f"  ELIF condition '{condition}' -> {cond_val}")
+                        conditional_stack[-1]['type'] = 'elif'  # Update state
+                        # Mark if this one executed
+                        conditional_stack[-1]['executed'] = cond_val
+                        if not cond_val:
+                            # Skip to the next ELIF, ELSE, or END
+                            line_ptr = self._find_matching_conditional_end(
+                                lines, line_ptr, ['elif', 'else', 'end'])
                             continue
 
-                    line_number = target_line - 1  # Convert to 0-based index
-                    continue
+                elif line.startswith(ELSE_KEYWORD):
+                    if not conditional_stack or conditional_stack[-1]['type'] not in ('if', 'elif'):
+                        raise ValueError("ELSE without matching IF/ELIF")
+                    # Optional DO? Let's require it for consistency
+                    match = re.match(r"ELSE\s+DO", line)
+                    if not match:
+                        raise ValueError(
+                            "Invalid ELSE syntax, expected 'ELSE DO'")
+
+                    if conditional_stack[-1]['executed']:
+                        # Previous block executed, skip to END
+                        line_ptr = self._find_matching_conditional_end(
+                            lines, conditional_stack[-1]['line'], ['end'])
+                        continue
+                    else:
+                        # Execute this ELSE block
+                        conditional_stack[-1]['type'] = 'else'  # Update state
+                        conditional_stack[-1]['executed'] = True
+
+                elif line.startswith(END_KEYWORD):
+                    # Optional semicolon? Let's require it.
+                    match = re.match(r"END\s*;", line)
+                    if not match:
+                        raise ValueError("Invalid END syntax, expected 'END;'")
+                    if not conditional_stack:
+                        raise ValueError("END without matching IF")
+                    conditional_stack.pop()  # Exit the current IF/ELIF/ELSE structure
 
-                elif "::(" in line:  # Function declaration
-                    skip_lines = self.handle_function_declaration(lines, line_number)
-                    line_number += skip_lines
-                elif "|>" in line:
-                    self.handle_function_call(line)
-                elif line.startswith(IF_KEYWORD):
-                    inside_if = True
-                    skip_lines = self.handle_if(line, lines, line_number)
                 elif line.startswith(FOR_KEYWORD):
-                    loop_stack.append((FOR_KEYWORD, line_number))
-                    line_number = self.handle_for(line, lines, line_number)
-                    continue
+                    match = re.match(
+                        r"FOR\s+([a-zA-Z_]\w*)\s+FROM\s+(.+?)\s+TO\s+(.+?)\s+DO", line
+                    )
+                    if not match:
+                        raise ValueError("Invalid FOR syntax")
+                    var_name, start_expr, end_expr = match.groups()
+
+                    start_val = evaluator.evaluate(start_expr, "int")
+                    end_val = evaluator.evaluate(end_expr, "int")
+
+                    # Check if this is the first entry into the loop
+                    if not loop_stack or loop_stack[-1][0] != 'for' or loop_stack[-1][1] != line_ptr:
+                        # Initialize loop variable and push state
+                        current_vars[var_name] = (start_val, "int")
+                        loop_stack.append(('for', line_ptr, var_name, end_val))
+                        if self.debug:
+                            print(
+                                f"  FOR loop start: {var_name}={start_val}, end={end_val}")
+                    else:
+                        # Increment existing loop variable
+                        current_val = current_vars[var_name][0]
+                        current_vars[var_name] = (current_val + 1, "int")
+                        if self.debug:
+                            print(
+                                f"  FOR loop increment: {var_name}={current_vars[var_name][0]}")
+
+                    # Check loop condition
+                    if current_vars[var_name][0] > end_val:  # Loop finished
+                        if self.debug:
+                            print(f"  FOR loop finished")
+                        loop_stack.pop()
+                        # Skip to end of loop body
+                        line_ptr = self._find_matching_loop_end(
+                            lines, line_ptr)
+                        # line_ptr will be incremented at the end, so skip LOOP_END line itself
+                        # continue
+
                 elif line.startswith(WHILE_KEYWORD):
-                    loop_stack.append((WHILE_KEYWORD, line_number))
-                    line_number = self.handle_while(line, lines, line_number)
-                    continue
+                    match = re.match(r"WHILE\s+(.+?)\s+DO", line)
+                    if not match:
+                        raise ValueError("Invalid WHILE syntax")
+                    condition = match.group(1)
+
+                    # Check if first entry
+                    if not loop_stack or loop_stack[-1][0] != 'while' or loop_stack[-1][1] != line_ptr:
+                        loop_stack.append(('while', line_ptr, condition))
+
+                    # Evaluate condition
+                    cond_val = evaluator.evaluate(condition, "bool")
+                    if self.debug:
+                        print(f"  WHILE condition '{condition}' -> {cond_val}")
+
+                    if not cond_val:  # Loop finished or condition initially false
+                        if self.debug:
+                            print(f"  WHILE loop finished/skipped")
+                        if loop_stack and loop_stack[-1][0] == 'while' and loop_stack[-1][1] == line_ptr:
+                            loop_stack.pop()  # Pop only if it was the current loop entry
+                        # Skip to end of loop body
+                        line_ptr = self._find_matching_loop_end(
+                            lines, line_ptr)
+                        # continue
+
                 elif line.startswith(LOOP_END_KEYWORD):
+                    # Optional semicolon? Require it.
+                    match = re.match(r"LOOP_END\s*;", line)
+                    if not match:
+                        raise ValueError(
+                            "Invalid LOOP_END syntax, expected 'LOOP_END;'")
                     if not loop_stack:
                         raise ValueError(
-                            f"{LOOP_END_KEYWORD} without matching {FOR_KEYWORD} or {WHILE_KEYWORD} on line {line_number + 1}"
-                        )
-                    loop_type, start_line = loop_stack.pop()
+                            f"{LOOP_END_KEYWORD} without matching FOR or WHILE")
 
-                    if loop_type == FOR_KEYWORD:
-                        pass  # For loop, simply go to next line after 'LOOP_END'
-                    elif loop_type == WHILE_KEYWORD:
-                        line_number = start_line
-                        continue
-                elif line.startswith(LET_KEYWORD):
-                    if (inside_if and skip_lines == 0) or not inside_if:
-                        self.handle_let(line)
-                elif line.startswith(REAS_KEYWORD):
-                    if (inside_if and skip_lines == 0) or not inside_if:
-                        self.handle_reas(line)
-                elif line.startswith(SHOW_KEYWORD):
-                    if (inside_if and skip_lines == 0) or not inside_if:
-                        self.handle_show(line)
-                elif (
-                    line.startswith(ELIF_KEYWORD)
-                    or line.startswith(ELSE_KEYWORD)
-                    or line.startswith(END_KEYWORD)
-                ):
-                    if not inside_if:
+                    loop_type, start_line_ptr, *_ = loop_stack[-1]
+
+                    if loop_type == 'for':
+                        # Jump back to the FOR line to increment and re-check
+                        line_ptr = start_line_ptr
+                        continue  # Re-execute the FOR line
+                    elif loop_type == 'while':
+                        # Jump back to the WHILE line to re-evaluate condition
+                        line_ptr = start_line_ptr
+                        continue  # Re-execute the WHILE line
+                    else:  # Should not happen
                         raise ValueError(
-                            f"Invalid command: {line}. {ELIF_KEYWORD}, {ELSE_KEYWORD}, and {END_KEYWORD} are only valid inside an {IF_KEYWORD} block"
-                        )
+                            "Internal error: Unknown loop type on stack")
+
+                # --- Return Statement ---
+                elif line.startswith(RETURN_KEYWORD):
+                    if local_vars is None:  # In global scope
+                        raise ValueError(
+                            "RETURN statement can only be used inside a function")
+                    expr = line[len(RETURN_KEYWORD):].strip()
+                    return_value = None
+                    if expr:
+                        # Need function's expected return type here
+                        # This requires passing function context down, or looking it up.
+                        # For now, evaluate without specific type.
+                        return_value = evaluator.evaluate(
+                            expr, None)  # Evaluate in local scope
+                    if self.debug:
+                        print(f"  Function returning: {repr(return_value)}")
+                    return return_value  # Exit the function execution
+
+                # --- Basic Commands ---
+                elif line.startswith(LET_KEYWORD):
+                    self.handle_let(line, current_vars, evaluator)
+                elif line.startswith(REAS_KEYWORD):
+                    self.handle_reas(line, current_vars, evaluator)
+                elif line.startswith(SHOW_KEYWORD):
+                    self.handle_show(line, evaluator)
+                elif "|>" in line:  # Function call as a statement
+                    self.handle_function_call(line, current_vars, evaluator)
+                # Add other simple statements here if needed
+
+                # --- Unknown Statement ---
                 else:
-                    raise ValueError(f"Invalid command: {line}")
+                    # Before declaring invalid, try evaluating as a standalone expression?
+                    # E.g. allow `x + 1` on a line? Let's disallow for now.
+                    raise ValueError(f"Unknown or invalid statement")
 
-            except ValueError as e:
-                print(f"Error on line {line_number + 1}: {e}")
-                return  # Or perhaps continue, depending on desired error handling
+            except (ValueError, TypeError, IndexError, ZeroDivisionError) as e:
+                # Catch evaluation and runtime errors
+                raise ValueError(
+                    f"Error on line {current_line_num}: {e}") from e
+            except Exception as e:
+                # Catch unexpected errors
+                raise RuntimeError(
+                    f"Unexpected error on line {current_line_num}: {type(e).__name__}: {e}") from e
 
-            if self.debug:
-                print(
-                    f"Current variables: {self.variables}\nCurrent functions: {self.functions}\nCurrent labels: {self.labels}\nCurrent return value: {self.return_value}\nCurrent line number: {line_number + 1}"
-                )
-                print("-" * 20)
-            line_number += 1
+            # --- Move to next line ---
+            line_ptr += 1
 
-    def handle_for(self, initial_for_line, lines, start_index):
-        """Handles FOR loops. Syntax: FOR var FROM start TO end DO ... LOOP_END"""
-        match = re.match(
-            r"FOR\s+([a-zA-Z_]\w*)\s+FROM\s+(.+)\s+TO\s+(.+)\s+DO", initial_for_line
-        )
-        if not match:
-            raise ValueError(f"Invalid FOR statement: {initial_for_line}")
+        # End of block reached
+        if loop_stack:
+            raise ValueError(
+                f"Reached end of block with unclosed loop(s) starting on line(s): {[l[1]+1 for l in loop_stack]}")
+        if conditional_stack:
+            raise ValueError(
+                f"Reached end of block with unclosed IF/ELIF/ELSE structure(s) starting on line(s): {[c['line']+1 for c in conditional_stack]}")
 
-        var_name, start_expr, end_expr = match.groups()
+        # If this is a function block, return None by default if no RETURN was hit
+        if local_vars is not None:
+            return None
+        # Global block execution doesn't explicitly return a value
+        return None
 
-        start_val = self.expression_evaluator.evaluate(start_expr, "int")
-        end_val = self.expression_evaluator.evaluate(end_expr, "int")
-
-        # Initialize loop variable
-        self.variables[var_name] = (start_val, "int")
-
-        current_index = start_index + 1
-        while self.variables[var_name][0] <= end_val:
-            while current_index < len(lines):
-                current_line = lines[current_index].strip()
-                if current_line.startswith("LOOP_END"):
-                    break  # Exit inner loop when LOOP_END is encountered
-                elif current_line.startswith("FOR"):
-                    current_index = self.handle_for(current_line, lines, current_index)
-                    continue
-                elif current_line.startswith("WHILE"):
-                    current_index = self.handle_while(
-                        current_line, lines, current_index
-                    )
-                    continue
-                else:
-                    # Execute lines within the loop
-                    self.execute_line(current_line)
-                current_index += 1
-
-            # Increment loop variable
-            self.variables[var_name] = (self.variables[var_name][0] + 1, "int")
-            current_index = start_index + 1
-
-        current_index = start_index + 1
-        while current_index < len(lines):
-            if lines[current_index].strip().startswith("LOOP_END"):
-                return current_index
-            current_index += 1
-        raise ValueError(
-            f"FOR loop starting on line {start_index + 1} has no matching LOOP_END"
-        )
-
-    def handle_while(self, initial_while_line, lines, start_index):
-        """Handles WHILE loops.  Syntax: WHILE condition DO ... LOOP_END"""
-        match = re.match(r"WHILE\s+(.+)\s+DO", initial_while_line)
-        if not match:
-            raise ValueError(f"Invalid WHILE statement: {initial_while_line}")
-
-        condition_str = match.group(1)
-        current_index = start_index + 1
-
-        while self.expression_evaluator.evaluate(condition_str, "bool"):
-            while current_index < len(lines):
-                current_line = lines[current_index].strip()
-                if current_line.startswith("LOOP_END"):
-                    break  # Exit the loop
-                elif current_line.startswith("FOR"):
-                    current_index = self.handle_for(current_line, lines, current_index)
-                    continue
-                elif current_line.startswith("WHILE"):
-                    current_index = self.handle_while(
-                        current_line, lines, current_index
-                    )
-                    continue
-                else:
-                    self.execute_line(current_line)
-                current_index += 1
-            current_index = start_index + 1
-
-        current_index = start_index + 1
-        while current_index < len(lines):
-            if lines[current_index].strip().startswith("LOOP_END"):
-                return current_index  # Return index of LOOP_END
-            current_index += 1
-        raise ValueError(
-            f"WHILE loop starting on line {start_index + 1} has no matching LOOP_END"
-        )
-
-    def handle_if(self, initial_if_line, lines, start_index):
-        """Handles IF-ELIF-ELSE-END blocks."""
-        match = re.match(r"IF\s+(.+)\s+DO", initial_if_line)
-        if not match:
-            raise ValueError(f"Invalid IF statement: {initial_if_line}")
-        condition_str = match.group(1)
-        condition_result = self.expression_evaluator.evaluate(condition_str, "bool")
-
-        block_executed = False
-        lines_to_skip = 0
-        current_index = start_index + 1
-
-        # Skip the IF block if condition is false
-        if not condition_result:
-            nesting_level = 0
-            while current_index < len(lines):
-                current_line = lines[current_index].strip()
-                if current_line.startswith("IF"):
-                    nesting_level += 1
-                elif current_line.startswith("END"):
+    def _find_matching_loop_end(self, lines, start_line_ptr):
+        """Finds the line index of the matching LOOP_END for a FOR/WHILE."""
+        nesting_level = 0
+        ptr = start_line_ptr + 1
+        while ptr < len(lines):
+            line = lines[ptr].split("%%")[0].strip()
+            if line.startswith((FOR_KEYWORD, WHILE_KEYWORD)):
+                nesting_level += 1
+            elif line.startswith(LOOP_END_KEYWORD):
+                match = re.match(r"LOOP_END\s*;", line)
+                if match:
                     if nesting_level == 0:
-                        break
+                        return ptr  # Found the matching end
                     nesting_level -= 1
-                elif nesting_level == 0 and (
-                    current_line.startswith("ELIF") or current_line.startswith("ELSE")
-                ):
-                    break
-                current_index += 1
-                lines_to_skip += 1
+            ptr += 1
+        raise ValueError(
+            f"Missing LOOP_END; for loop starting on line {start_line_ptr + 1}")
 
-        # Execute the IF block if condition is true
-        if condition_result:
-            block_executed = True
-            while current_index < len(lines):
-                current_line = lines[current_index].strip()
-                if (
-                    current_line.startswith("ELIF")
-                    or current_line.startswith("ELSE")
-                    or current_line.startswith("END")
-                ):
-                    break
-                elif current_line.startswith("IF"):
-                    lines_to_skip_nested_if = self.handle_if(
-                        current_line, lines, current_index
-                    )
-                    current_index += lines_to_skip_nested_if + 1
-                    lines_to_skip += lines_to_skip_nested_if + 1
+    def _find_matching_conditional_end(self, lines, start_line_ptr, targets):
+        """Finds the next ELIF, ELSE, or END at the same nesting level."""
+        nesting_level = 0
+        ptr = start_line_ptr + 1
+        while ptr < len(lines):
+            line = lines[ptr].split("%%")[0].strip()
+            if line.startswith(IF_KEYWORD):
+                nesting_level += 1
+            elif line.startswith(END_KEYWORD):
+                match = re.match(r"END\s*;", line)
+                if match:
+                    if nesting_level == 0:
+                        # Found the END for the starting IF
+                        return ptr if 'end' in targets else ptr  # Adjust based on target needs
+                    nesting_level -= 1
+            elif nesting_level == 0:
+                # Check for targets only at the same level
+                if any(line.startswith(k.upper()) for k in targets):
+                    # Check syntax more strictly?
+                    if line.startswith(ELIF_KEYWORD) and 'elif' in targets:
+                        return ptr
+                    if line.startswith(ELSE_KEYWORD) and 'else' in targets:
+                        return ptr
+                    # Add END check here too?
+            ptr += 1
+        # If searching for END and not found
+        if 'end' in targets:
+            raise ValueError(
+                f"Missing END; for IF block starting on line {start_line_ptr + 1}")
+        # If searching for ELIF/ELSE and not found, return line count (effectively end of block)
+        return len(lines)
+
+    # Remove handle_for, handle_while, handle_if - logic moved into execute_block
+
+    def execute_line(self, line, line_num_for_error, current_vars):
+        """
+        Executes a single line in the given variable context.
+        Used primarily by REPL or potentially simple sub-execution.
+        NOTE: This is a simplified version and won't handle control flow correctly.
+              The main execution logic is in `execute_block`.
+        """
+        evaluator = ExpressionEvaluator(
+            current_vars, self.functions, self, self.debug)
+        line = line.strip()
+        if not line or line.startswith("%%"):
+            return None
+
+        try:
+            # --- Seed Command (NEW for REPL) ---
+            if line.startswith('?'): # Quick check before regex
+                seed_match = re.match(r"\?\s+(.+)", line)
+                if seed_match:
+                    seed_value_str = seed_match.group(1).strip()
+                    try:
+                        seed_value_for_func = int(seed_value_str)
+                        random.seed(seed_value_for_func)
+                        if self.debug: print(f"  Seeded random generator with int: {seed_value_for_func}")
+                    except ValueError:
+                        seed_value_for_func = seed_value_str
+                        random.seed(seed_value_for_func)
+                        if self.debug: print(f"  Seeded random generator with string: '{seed_value_for_func}'")
+                    return None # Seed command handled, return nothing
                 else:
-                    self.execute_line(current_line)
-                    current_index += 1
-                    lines_to_skip += 1
-
-        # Process ELIF blocks if no block has been executed
-        while not block_executed and current_index < len(lines):
-            current_line = lines[current_index].strip()
-
-            if current_line.startswith("ELIF"):
-                match = re.match(r"ELIF\s+(.+)\s+DO", current_line)
-                if not match:
-                    raise ValueError(f"Invalid ELIF statement: {current_line}")
-                condition_str = match.group(1)
-                condition_result = self.expression_evaluator.evaluate(
-                    condition_str, "bool"
-                )
-                current_index += 1
-                lines_to_skip += 1
-
-                if condition_result:
-                    block_executed = True
-                    while current_index < len(lines):
-                        current_line = lines[current_index].strip()
-                        if (
-                            current_line.startswith("ELIF")
-                            or current_line.startswith("ELSE")
-                            or current_line.startswith("END")
-                        ):
-                            break
-                        elif current_line.startswith("IF"):
-                            lines_to_skip_nested_if = self.handle_if(
-                                current_line, lines, current_index
-                            )
-                            current_index += lines_to_skip_nested_if + 1
-                            lines_to_skip += lines_to_skip_nested_if + 1
-                        else:
-                            self.execute_line(current_line)
-                            current_index += 1
-                            lines_to_skip += 1
-                else:
-                    # Skip this ELIF block
-                    nesting_level = 0
-                    while current_index < len(lines):
-                        current_line = lines[current_index].strip()
-                        if current_line.startswith("IF"):
-                            nesting_level += 1
-                        elif current_line.startswith("END"):
-                            if nesting_level == 0:
-                                break
-                            nesting_level -= 1
-                        elif nesting_level == 0 and (
-                            current_line.startswith("ELIF")
-                            or current_line.startswith("ELSE")
-                        ):
-                            break
-                        current_index += 1
-                        lines_to_skip += 1
-            elif current_line.startswith("ELSE"):
-                block_executed = True
-                current_index += 1
-                lines_to_skip += 1
-                while current_index < len(lines):
-                    current_line = lines[current_index].strip()
-                    if current_line.startswith("END"):
-                        break
-                    elif current_line.startswith("IF"):
-                        lines_to_skip_nested_if = self.handle_if(
-                            current_line, lines, current_index
-                        )
-                        current_index += lines_to_skip_nested_if + 1
-                        lines_to_skip += lines_to_skip_nested_if + 1
-                    else:
-                        self.execute_line(current_line)
-                        current_index += 1
-                        lines_to_skip += 1
-            elif current_line.startswith("END"):
-                break
+                    raise ValueError("Invalid seed syntax. Expected '? <seed_value>'")
+            elif line.startswith(LET_KEYWORD):
+                return self.handle_let(line, current_vars, evaluator)
+            elif line.startswith(REAS_KEYWORD):
+                return self.handle_reas(line, current_vars, evaluator)
+            elif line.startswith(SHOW_KEYWORD):
+                return self.handle_show(line, evaluator)
+            elif "|>" in line:  # Function call statement
+                return self.handle_function_call(line, current_vars, evaluator)
+            elif "::(" in line:  # Function definition (only declaration in REPL context)
+                print("Function defined (syntax checked).")
+                # Assume void return for REPL def
+                return self.handle_function_declaration([line, "<-void"], 0, store_function=True)
+            elif line.startswith((IF_KEYWORD, FOR_KEYWORD, WHILE_KEYWORD, GOTO_KEYWORD, LABEL_KEYWORD, RETURN_KEYWORD, LOOP_END_KEYWORD, END_KEYWORD)):
+                raise ValueError(
+                    f"Control flow statements ({line.split()[0]}) are not fully supported for single-line execution.")
             else:
-                current_index += 1
-                lines_to_skip += 1
+                # Try to evaluate as a standalone expression? Only for REPL?
+                # Let's disallow for now to be consistent with file execution.
+                raise ValueError(f"Unknown command or invalid statement")
 
-        # Skip to the END statement
-        while current_index < len(lines):
-            current_line = lines[current_index].strip()
-            if current_line.startswith("END"):
-                break
-            current_index += 1
-            lines_to_skip += 1
+        except (ValueError, TypeError, IndexError, ZeroDivisionError) as e:
+            raise ValueError(
+                f"Error on line {line_num_for_error + 1}: {e}") from e
+        except Exception as e:
+            raise RuntimeError(
+                f"Unexpected error on line {line_num_for_error + 1}: {type(e).__name__}: {e}") from e
 
-        # Skip the END statement itself
-        if current_index < len(lines) and lines[current_index].strip().startswith(
-            "END"
-        ):
-            current_index += 1
-            lines_to_skip += 1
-
-        return lines_to_skip
-
-    def execute_line(self, line):
-        """Executes a single line of code."""
-        if line.startswith(LET_KEYWORD):
-            self.handle_let(line)
-        elif "|>" in line:  # Function call
-            return self.handle_function_call(line)
-        elif line.startswith(SHOW_KEYWORD):
-            self.handle_show(line)
-        elif line.startswith(REAS_KEYWORD):
-            self.handle_reas(line)
-        elif "::(" in line:  # Function declaration
-            return self.handle_function_declaration([line], 0)
-        else:
-            raise ValueError(f"Invalid command: {line}")
-
-    def handle_let(self, line):
-        """Handles LET statements."""
+    def handle_let(self, line, current_vars, evaluator):
+        """Handles LET statements in the specified variable scope."""
         match = re.match(r"LET\s+([a-zA-Z_]\w*)\s*:\s*(\w+)\s*=\s*(.+)", line)
         if not match:
-            raise ValueError(f"Invalid LET statement: {line}")
+            raise ValueError(f"Invalid LET syntax")
 
         var_name, var_type, expression = match.groups()
         if self.debug:
@@ -1073,167 +1649,357 @@ List Operations:
 
         if var_type not in self.supported_types:
             raise ValueError(f"Unsupported data type: {var_type}")
+        if var_name in current_vars:
+            # Allow redefining in REPL maybe, but error in script?
+            # Let's error consistently for now.
+            raise ValueError(
+                f"Variable '{var_name}' already exists. Use REAS to reassign.")
 
-        value = self.expression_evaluator.evaluate(expression, var_type)
-        if var_name in self.variables:
+        # Use the provided evaluator which uses current_vars
+        value = evaluator.evaluate(expression, var_type)
+
+        # Check if the evaluated type matches the declared type after conversion attempt
+        final_type = _get_python_type_name(value)
+        # allow int to be assigned to float
+        if var_type != "any" and final_type != var_type and not (var_type == "float" and final_type == "int"):
+            # This check might be redundant if evaluate enforces expected_type strictly
             print(
-                f"Error: Variable {var_name} already exists. Use REAS to reassign a variable"
-            )
-            return
-        self.variables[var_name] = (value, var_type)
-        if self.debug:
-            print(f"Declared variable: {var_name} = {value} (type: {var_type})")
+                f"Warning: Evaluated type '{final_type}' differs from declared type '{var_type}' for '{var_name}'. Value: {repr(value)}")
+            # Re-convert to be sure? Or trust evaluate? Let's trust evaluate for now.
 
-    def handle_reas(self, line):
-        """Handles REAS statements."""
+        current_vars[var_name] = (value, var_type)
+        if self.debug:
+            print(
+                f"  LET Declared: {var_name} = {repr(value)} (type: {var_type})")
+
+    def handle_reas(self, line, current_vars, evaluator):
+        """Handles REAS statements in the specified variable scope."""
+        # Handle list operations disguised as REAS first
+        # Example: REAS myList = myList value [a]
+        # Check if RHS starts with var name
+        list_op_match = re.match(
+            r"REAS\s+([a-zA-Z_]\w*)\s*=\s*(\1\s+.+)", line)
+        if list_op_match:
+            var_name, list_op_expr = list_op_match.groups()
+            if var_name not in current_vars:
+                raise ValueError(f"Variable '{var_name}' not defined.")
+            # Try evaluating the RHS as a potential list operation expression
+            try:
+                new_value = evaluator.evaluate(
+                    # Expect original type
+                    list_op_expr, current_vars[var_name][1])
+                # Evaluator's list op should have modified in-place for lists,
+                # or returned new value for strings. Reassign necessary for strings.
+                current_vars[var_name] = (new_value, current_vars[var_name][1])
+                if self.debug:
+                    print(f"  REAS (List Op): {var_name} = {repr(new_value)}")
+                return  # Done with list operation reassignment
+            except ValueError:
+                # If it fails, it might be a regular reassignment below
+                if self.debug:
+                    print("  List op eval failed, trying regular REAS")
+                pass
+
+        # Regular REAS
         match = re.match(r"REAS\s+([a-zA-Z_]\w*)\s*=\s*(.+)", line)
         if not match:
-            raise ValueError(f"Invalid REAS statement: {line}")
+            raise ValueError(f"Invalid REAS syntax")
 
         var_name, expression = match.groups()
 
-        if var_name not in self.variables:
+        if var_name not in current_vars:
+            raise ValueError(
+                f"Variable '{var_name}' does not exist. Use LET to declare.")
+
+        original_type = current_vars[var_name][1]
+        if self.debug:
             print(
-                f"Error: Variable {var_name} does not exist. Use LET to create a variable"
-            )
-            return
-        var_type = self.variables[var_name][1]  # Get the original type
-        if self.debug:
-            print(f"  Parsed REAS: var_name={var_name}, expression={expression}")
+                f"  Parsed REAS: var_name={var_name} (type: {original_type}), expression={expression}")
 
-        value = self.expression_evaluator.evaluate(expression, var_type)
-        self.variables[var_name] = (value, var_type)
-        if self.debug:
-            print(f"Reassigned variable: {var_name} = {value} (type: {var_type})")
+        # Evaluate the expression, expecting the variable's original type
+        value = evaluator.evaluate(expression, original_type)
 
-    def handle_show(self, line):
+        # Type check after evaluation (optional, depends on strictness)
+        final_type = _get_python_type_name(value)
+        if original_type != "any" and final_type != original_type and not (original_type == "float" and final_type == "int"):
+            print(
+                f"Warning: Reassigning '{var_name}' of type '{original_type}' with value of type '{final_type}'. Value: {repr(value)}")
+            # Allow reassignment but warn? Or error? Let's allow with warning.
+
+        # Keep original declared type
+        current_vars[var_name] = (value, original_type)
+        if self.debug:
+            print(
+                f"  REAS Reassigned: {var_name} = {repr(value)} (type: {original_type})")
+
+    def handle_show(self, line, evaluator):
         """Handles SHOW statements."""
-        match = re.match(r"SHOW\((.+)\)", line)
+        match = re.match(r"SHOW\((.+)\)", line,
+                         re.DOTALL)  # Allow multiline expressions
         if not match:
-            raise ValueError(f"Invalid SHOW statement: {line}")
+            raise ValueError(f"Invalid SHOW syntax, expected SHOW(...)")
 
         expression = match.group(1).strip()
         if self.debug:
             print(f"  Parsed SHOW: expression={expression}")
-            print(f"  {self.variables}")
+            # Show context used by evaluator
+            print(f"  SHOW Vars: {evaluator.variables}")
         try:
-            # Check if the expression involves string concatenation
-            if "+" in expression and expression.replace(" ", "").startswith('"'):
-                value = self.expression_evaluator._evaluate_string_concatenation(
-                    expression
-                )
-            else:
-                value = self.expression_evaluator.evaluate(expression, None)
+            # Evaluate expecting *any* type, let print handle formatting
+            value = evaluator.evaluate(expression, None)
             if self.debug or self.debug_show:
-                print(f"SHOW: {value}")
+                # Use repr for debug clarity
+                print(f"SHOW Output: {repr(value)}")
             else:
-                print(value)
-        except ValueError as e:
-            print(f"Error in SHOW: {e}")
+                # Smart printing: avoid None, format lists/bools nicely
+                if value is None:
+                    # Maybe print "None" or "(void)"? Let's print nothing.
+                    pass
+                elif isinstance(value, bool):
+                    print(str(value).lower())  # print 'true'/'false'
+                elif isinstance(value, list):
+                    # Print list elements separated by space? Or Python-like repr?
+                    # Let's use standard print for now.
+                    print(value)
+                else:
+                    print(value)
+        except (ValueError, TypeError, IndexError, ZeroDivisionError) as e:
+            # Catch evaluation errors during SHOW
+            print(f"Error in SHOW expression '{expression}': {e}")
+            # Don't raise, just print error for SHOW
 
-    def handle_function_declaration(self, lines: List[str], start_index: int) -> int:
-        """Handles function declaration and returns number of lines to skip"""
-        # Parse function declaration line
+    def handle_function_declaration(self, lines: List[str], start_index: int, store_function: bool) -> int:
+        """
+        Parses function declaration, optionally stores it, and returns number of lines in the function body+return.
+        Raises ValueError on syntax errors.
+        """
         decl_line = lines[start_index].strip()
-        match = re.match(r"([a-zA-Z_]\w*)::\((.*?)\)->", decl_line)
+        # Allow spaces around ::
+        match = re.match(r"([a-zA-Z_]\w*)\s*::\s*\((.*?)\)\s*->", decl_line)
         if not match:
-            raise ValueError(f"Invalid function declaration: {decl_line}")
+            raise ValueError(
+                f"Invalid function declaration syntax: {decl_line}")
 
         func_name, params_str = match.groups()
+        if self.debug and store_function:
+            print(f"  Parsing function decl: {func_name}")
 
         # Parse parameters
-        params = []
+        params: List[tuple[str, str]] = []
+        param_names = set()
         if params_str.strip():
-            for param in params_str.split(","):
-                param = param.strip()
-                param_match = re.match(r"([a-zA-Z_]\w*):(\w+)", param)
+            for i, param_part in enumerate(params_str.split(",")):
+                param_part = param_part.strip()
+                if not param_part:
+                    raise ValueError(
+                        f"Empty parameter declaration in function '{func_name}'")
+                param_match = re.match(
+                    r"([a-zA-Z_]\w*)\s*:\s*(\w+)", param_part)
                 if not param_match:
-                    raise ValueError(f"Invalid parameter declaration: {param}")
+                    raise ValueError(
+                        f"Invalid parameter syntax '{param_part}' in function '{func_name}'")
                 param_name, param_type = param_match.groups()
+
+                if param_type not in self.supported_types:
+                    raise ValueError(
+                        f"Unsupported parameter type '{param_type}' for '{param_name}' in function '{func_name}'")
+                if param_name in param_names:
+                    raise ValueError(
+                        f"Duplicate parameter name '{param_name}' in function '{func_name}'")
                 params.append((param_name, param_type))
+                param_names.add(param_name)
 
-        # Collect function body
-        body = []
+        # Collect function body and find return type
+        body_lines = []
+        return_type = None
         current_index = start_index + 1
+        # Count lines belonging to the function (body + return)
+        lines_processed = 0
+        nesting = 0  # Track nested functions if ever supported
+
         while current_index < len(lines):
-            line = lines[current_index].strip()
-            if line.startswith("<-"):
-                # Parse return type
-                return_type = line[2:].strip()
-                if return_type not in self.supported_types:
-                    raise ValueError(f"Unsupported return type: {return_type}")
+            # Keep indentation, split comment later
+            line = lines[current_index]
+            line_content = line.split("%%")[0].strip()
 
-                # Store function
-                self.functions[func_name] = Function(
-                    func_name, params, body, return_type
-                )
-                return len(body)
+            # Handle end of function body
+            if line_content.startswith("<-"):
+                if nesting == 0:
+                    parsed_return_type = line_content[2:].strip()
+                    if not parsed_return_type:
+                        raise ValueError(
+                            f"Missing return type after '<-' in function '{func_name}' on line {current_index + 1}")
+                    if parsed_return_type not in self.supported_types:
+                        raise ValueError(
+                            f"Unsupported return type '{parsed_return_type}' in function '{func_name}'")
+                    return_type = parsed_return_type
+                    lines_processed += 1  # Count the return line
+                    break  # Function definition complete
+                else:
+                    # Part of nested function body
+                    body_lines.append(line)
+                    lines_processed += 1
+
+            # Rudimentary check for nested functions - needs proper parsing if implemented
+            elif "::(" in line_content and line_content.endswith("->"):
+                nesting += 1
+                body_lines.append(line)
+                lines_processed += 1
+            # Add line to body
+            else:
+                body_lines.append(line)
+                lines_processed += 1
 
-            body.append(line)
             current_index += 1
+        # --- End of loop ---
 
-        raise ValueError(f"Function {func_name} has no return type declaration")
+        if return_type is None:
+            raise ValueError(
+                f"Function '{func_name}' defined starting on line {start_index + 1} has no return type declaration ('<- type')")
 
-    def handle_function_call(self, line: str) -> Any:
-        """Handles function calls with the |> operator"""
+        # Store the function if requested (during pre-scan)
+        if store_function:
+            if func_name in self.functions:
+                raise ValueError(f"Function '{func_name}' already defined.")
+            self.functions[func_name] = Function(
+                func_name, params, body_lines, return_type)
+            if self.debug:
+                print(
+                    f"  Stored function '{func_name}' ({len(params)} params, {len(body_lines)} body lines, returns {return_type})")
+
+        return lines_processed  # Return number of lines consumed by body + return
+
+    def handle_function_call(self, line: str, caller_vars: Dict[str, tuple[Any, str]], caller_evaluator: ExpressionEvaluator) -> Any:
+        """Handles function calls with the |> operator, manages scope."""
         if self.debug:
-            print(f"  Parsed function call: {line}")
+            print(f"  Handling function call statement: {line}")
         match = re.match(r"(\(.*?\)|_)\s*\|>\s*([a-zA-Z_]\w*)", line)
         if not match:
-            raise ValueError(f"Invalid function call: {line}")
+            # Maybe it's part of a REAS? e.g. REAS result = (...) |> func
+            # Let REAS handle the expression evaluation in that case.
+            # If it's a standalone line, it's an error here.
+            raise ValueError(f"Invalid function call syntax")
 
         args_str, func_name = match.groups()
 
         if func_name not in self.functions:
-            raise ValueError(f"Undefined function: {func_name}")
+            raise ValueError(f"Undefined function: '{func_name}'")
 
         func = self.functions[func_name]
+        if self.debug:
+            print(
+                f"  Calling function '{func_name}' (returns {func.return_type})")
 
-        # Parse arguments
-        args = []
-        if args_str != "_" and args_str.strip():
-            args_str = args_str[1:-1]
-            args = [arg.strip() for arg in args_str.split(",")]
+        # --- Argument Parsing and Evaluation ---
+        evaluated_args = []
+        if args_str != "_" and args_str.strip() != "()":  # Allow () for no args
+            args_str_content = args_str[1:-1].strip()
+            if args_str_content:
+                # Simple split by comma - might fail with commas inside nested calls or literals
+                # A more robust parser is needed for complex arguments.
+                arg_expressions = [arg.strip()
+                                   for arg in args_str_content.split(",")]
 
-        if len(args) != len(func.params):
+                if len(arg_expressions) != len(func.params):
+                    raise ValueError(
+                        f"Function '{func_name}' expects {len(func.params)} arguments, but got {len(arg_expressions)}"
+                    )
+
+                # Evaluate arguments *in the caller's scope*
+                for i, arg_expr in enumerate(arg_expressions):
+                    param_name, param_type = func.params[i]
+                    try:
+                        arg_value = caller_evaluator.evaluate(
+                            arg_expr, param_type)
+                        evaluated_args.append(arg_value)
+                        if self.debug:
+                            print(
+                                f"    Arg '{param_name}': '{arg_expr}' -> {repr(arg_value)}")
+                    except (ValueError, TypeError, IndexError) as e:
+                        raise ValueError(
+                            f"Error evaluating argument {i+1} ('{param_name}') for function '{func_name}': {e}")
+            elif len(func.params) != 0:  # () provided but function expects args
+                raise ValueError(
+                    f"Function '{func_name}' expects {len(func.params)} arguments, but got 0")
+
+        elif args_str == "_" and len(func.params) != 0:
             raise ValueError(
-                f"Function {func_name} expects {len(func.params)} arguments, got {len(args)}"
-            )
+                f"Function '{func_name}' expects {len(func.params)} arguments, but got '_' (no arguments passed)")
+        elif args_str == "()" and len(func.params) != 0:
+            raise ValueError(
+                f"Function '{func_name}' expects {len(func.params)} arguments, but got 0")
+        # Should be covered above, but double check
+        elif len(evaluated_args) != len(func.params):
+            # This case might occur if args_str is empty/invalid when params expected
+            raise ValueError(
+                f"Argument count mismatch for function '{func_name}': expected {len(func.params)}, got {len(evaluated_args)}")
 
-        # Create new scope for function variables
-        old_variables = self.variables.copy()
-        self.variables = {}
-        self.variables.update(old_variables)
+        # --- Scope Setup ---
+        local_vars: Dict[str, tuple[Any, str]] = {}
+        # Bind evaluated arguments to parameter names in the local scope
+        for i, (param_name, param_type) in enumerate(func.params):
+            local_vars[param_name] = (evaluated_args[i], param_type)
+        if self.debug:
+            print(
+                f"  Function '{func_name}' local scope initialized: {local_vars}")
 
-        # Evaluate and bind arguments to parameters
-        for (param_name, param_type), arg in zip(func.params, args):
-            value = self.expression_evaluator.evaluate(arg, param_type)
-            self.variables[param_name] = (value, param_type)
+        # --- Execute Function Body ---
+        # The function body uses its own evaluator with the local scope
+        return_value = self.execute_block(func.body, local_vars)
 
-        # Execute function body
-        self.return_value = None
-        for line in func.body:
-            if line.startswith("RETURN "):
-                expr = line[7:].strip()
-                self.return_value = self.expression_evaluator.evaluate(
-                    expr, func.return_type
-                )
-                break
-            else:
-                self.execute_line(line)
+        # --- Type Check Return Value ---
+        if return_value is None and func.return_type != "void":
+            print(
+                f"Warning: Function '{func_name}' reached end without RETURN, but expected '{func.return_type}'. Returning None.")
+            # Convert None to the expected type if possible (e.g., 0 for int, "" for string)
+            try:
+                # Use a temporary evaluator for this conversion
+                temp_eval = ExpressionEvaluator({}, {}, self, self.debug)
+                return_value = temp_eval._convert_type(
+                    None, "void", func.return_type)
+                if self.debug:
+                    print(
+                        f"  Converted implicit None return to: {repr(return_value)} ({func.return_type})")
+            except ValueError:
+                # If conversion fails, return None anyway
+                pass
+        elif return_value is not None:
+            # Check if the actual return value matches the declared return type
+            actual_return_type = _get_python_type_name(return_value)
+            if func.return_type != "any" and actual_return_type != func.return_type and not (func.return_type == "float" and actual_return_type == "int"):
+                # Try to convert to the declared type
+                try:
+                    # Use a temporary evaluator for this conversion
+                    temp_eval = ExpressionEvaluator({}, {}, self, self.debug)
+                    converted_return_value = temp_eval._convert_type(
+                        return_value, actual_return_type, func.return_type)
+                    if self.debug:
+                        print(
+                            f"  Converted return value from {actual_return_type} to {func.return_type}: {repr(converted_return_value)}")
+                    return_value = converted_return_value
+                except ValueError as e:
+                    raise ValueError(
+                        f"Function '{func_name}' returned type '{actual_return_type}' but expected '{func.return_type}', and conversion failed: {e}")
 
-        # Restore original scope
-        # self.variables = old_variables
+        if self.debug:
+            print(
+                f"  Function '{func_name}' finished execution, returning: {repr(return_value)}")
 
-        return self.return_value
+        # Return the final (potentially type-checked and converted) value
+        return return_value
 
 
+# Part 5: `main` function and entry point (No major changes needed)
+
 def main():
-    parser = argparse.ArgumentParser(description="A simple code interpreter.")
-    parser.add_argument("filepath", nargs="?", help="The path to the script file.")
-    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug mode.")
+    parser = argparse.ArgumentParser(
+        description="Pepper Programming Language Interpreter.")
+    parser.add_argument("filepath", nargs="?",
+                        help="The path to the script file to execute.")
+    parser.add_argument("-d", "--debug", action="store_true",
+                        help="Enable detailed execution tracing.")
     parser.add_argument(
-        "-s", "--debug_show", action="store_true", help="Enable debug show mode."
+        "-s", "--debug_show", action="store_true", help="Enable debug output specifically for SHOW statements."
     )
     args = parser.parse_args()
 
diff --git i/rps.pep w/rps.pep
index 7e32a8d..69564c2 100644
--- i/rps.pep
+++ w/rps.pep
@@ -26,6 +26,6 @@ IF p1index && p2index DO
     SHOW("It's a TIE!")
 ELIF mod && 1 DO
     SHOW("Player 2 Wins!")
-ELSE
+ELSE DO
     SHOW("Player 1 Wins!")
-END
+END;
diff --git i/rps2.pep w/rps2.pep
index c03b5e2..480880a 100644
--- i/rps2.pep
+++ w/rps2.pep
@@ -28,9 +28,9 @@ IF mod && 0 DO
     SHOW("It's a TIE!")
 ELIF mod && 1 DO
     SHOW("Player 2 Wins!")
-ELSE
+ELSE DO
     SHOW("Player 1 Wins!")
-END
+END;
 
 REAS input = INPT("Play again? [yes/no]")
 GOTO start; input [i] 1 && "y"
